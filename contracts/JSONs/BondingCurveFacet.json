{"language":"Solidity","sources":{"contracts/contracts/facets/BondingCurveFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\nimport { BondingCurveSale } from \"../sales/BondingCurveSale.sol\";\n\ncontract BondingCurveFacet {\n  event BondingCurveDeployed(uint256 indexed labId, address curve);\n\n  error Unauthorized();\n  error InvalidLabId();\n  error VaultNotDeployed();\n  error CurveAlreadyExists();\n  error TreasuryNotSet();\n\n  function deployBondingCurve(uint256 labId) external returns (address curve) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    if (hs.labs[labId].owner == address(0)) revert InvalidLabId();\n    if (hs.labs[labId].owner != msg.sender) revert Unauthorized();\n    if (hs.labIdToVault[labId] == address(0)) revert VaultNotDeployed();\n    if (hs.labIdToCurve[labId] != address(0)) revert CurveAlreadyExists();\n    if (hs.protocolTreasury == address(0)) revert TreasuryNotSet();\n\n    curve = address(new BondingCurveSale(\n      hs.labsToken,\n      hs.labIdToVault[labId],\n      hs.protocolTreasury,\n      hs.curveFeeBps,\n      hs.curvePolBps\n    ));\n    hs.labIdToCurve[labId] = curve;\n    emit BondingCurveDeployed(labId, curve);\n  }\n  \n  function getBondingCurve(uint256 labId) external view returns (address) {\n    return LibH1Storage.h1Storage().labIdToCurve[labId];\n  }\n}\n\n\n"},"contracts/contracts/sales/BondingCurveSale.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ILabVaultLike {\n  function depositLABS(uint256 assets, address receiver) external returns (uint256 shares);\n  function assetsPerShare() external view returns (uint256);\n}\n\ninterface IERC20Like {\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n}\n\n/// @title BondingCurveSale\n/// @notice Bonding curve implementation for purchasing lab vault shares\n/// @dev Includes slippage protection and fee caps to prevent exploitation\ncontract BondingCurveSale {\n  address public immutable labsToken;\n  ILabVaultLike public immutable vault;\n  address public immutable treasury;\n\n  uint16 public feeBps;\n  uint16 public polBps;\n  \n  uint16 public constant MAX_FEE_BPS = 1000;  // 10% max fee\n  uint16 public constant MAX_POL_BPS = 1000;  // 10% max POL\n  uint256 private constant BPS_DENOMINATOR = 10_000;\n  uint256 private constant PRICE_PREMIUM_BPS = 1005; // 0.5% premium\n  uint256 private constant PRICE_BASE = 1000;\n  \n  // Price bounds for validation (prevents price manipulation)\n  uint256 public constant MIN_PRICE = 1e15;     // 0.001 LABS minimum\n  uint256 public constant MAX_PRICE = 1e24;     // 1,000,000 LABS maximum\n  uint256 public constant MAX_PRICE_CHANGE_BPS = 5000; // 50% max change per tx\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n  uint256 private lastPrice;\n\n  // Pausable functionality for emergency response\n  bool private _paused;\n  address public admin;\n\n  event Purchased(address indexed buyer, uint256 labsIn, uint256 sharesOut, uint256 feeLabs, uint256 polLabs);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n  event AdminUpdated(address indexed newAdmin);\n\n  error ReentrancyGuard();\n  error InvalidAddress();\n  error InvalidAmount();\n  error SlippageExceeded();\n  error TransferFailed();\n  error FeeTooHigh();\n  error PriceOutOfBounds();\n  error PriceChangeExcessive();\n  error ContractPaused();\n  error Unauthorized();\n\n  modifier nonReentrant() {\n    if (status == ENTERED) revert ReentrancyGuard();\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  constructor(address labsToken_, address vault_, address treasury_, uint16 feeBps_, uint16 polBps_) {\n    if (labsToken_ == address(0) || vault_ == address(0) || treasury_ == address(0)) {\n      revert InvalidAddress();\n    }\n    if (feeBps_ > MAX_FEE_BPS) revert FeeTooHigh();\n    if (polBps_ > MAX_POL_BPS) revert FeeTooHigh();\n    \n    labsToken = labsToken_;\n    vault = ILabVaultLike(vault_);\n    treasury = treasury_;\n    feeBps = feeBps_;\n    polBps = polBps_;\n    admin = msg.sender; // Deployer is initial admin\n  }\n\n  /// @notice Returns current price per share with 0.5% premium\n  /// @dev Price based on vault's NAV with premium factor and validation\n  /// @return Current price per share in LABS tokens\n  function price() public view returns (uint256) {\n    uint256 nav = vault.assetsPerShare();\n    uint256 currentPrice = (nav * PRICE_PREMIUM_BPS) / PRICE_BASE;\n    \n    // Validate price is within bounds\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) {\n      return MIN_PRICE; // Fallback to minimum safe price\n    }\n    \n    return currentPrice;\n  }\n\n  /// @notice Validates price hasn't changed excessively\n  /// @dev Prevents price manipulation attacks\n  /// @param currentPrice Current price to validate\n  function _validatePriceChange(uint256 currentPrice) private {\n    if (lastPrice == 0) {\n      lastPrice = currentPrice;\n      return;\n    }\n    \n    uint256 priceDiff;\n    uint256 changePercentBps;\n    \n    if (currentPrice > lastPrice) {\n      priceDiff = currentPrice - lastPrice;\n      changePercentBps = (priceDiff * BPS_DENOMINATOR) / lastPrice;\n    } else {\n      priceDiff = lastPrice - currentPrice;\n      changePercentBps = (priceDiff * BPS_DENOMINATOR) / lastPrice;\n    }\n    \n    if (changePercentBps > MAX_PRICE_CHANGE_BPS) revert PriceChangeExcessive();\n    lastPrice = currentPrice;\n  }\n\n  /// @notice Purchase vault shares with LABS tokens\n  /// @dev Includes slippage protection via minSharesOut parameter\n  /// @param labsAmount Amount of LABS tokens to spend\n  /// @param receiver Address to receive the vault shares\n  /// @param minSharesOut Minimum shares to receive (slippage protection)\n  /// @return sharesOut Actual amount of shares received\n  /// @custom:reverts InvalidAmount if labsAmount is zero\n  /// @custom:reverts InvalidAddress if receiver is zero address\n  /// @custom:reverts SlippageExceeded if sharesOut < minSharesOut\n  /// @custom:reverts TransferFailed if any token transfer fails\n  /// @custom:reverts ContractPaused if contract is paused\n  function buy(uint256 labsAmount, address receiver, uint256 minSharesOut) external nonReentrant whenNotPaused returns (uint256 sharesOut) {\n    if (labsAmount == 0) revert InvalidAmount();\n    if (receiver == address(0)) revert InvalidAddress();\n    \n    // Validate price before purchase\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n    \n    uint256 fee = (labsAmount * feeBps) / BPS_DENOMINATOR;\n    uint256 pol = (labsAmount * polBps) / BPS_DENOMINATOR;\n    uint256 toDeposit = labsAmount - fee - pol;\n\n    // Transfer tokens from sender\n    if (!IERC20Like(labsToken).transferFrom(msg.sender, address(this), labsAmount)) {\n      revert TransferFailed();\n    }\n    \n    // Distribute fee to treasury\n    if (fee > 0 && !IERC20Like(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n    // Route POL to treasury as well (protocol-owned liquidity reserve)\n    if (pol > 0 && !IERC20Like(labsToken).transfer(treasury, pol)) {\n      revert TransferFailed();\n    }\n    \n    // Approve vault to spend tokens using robust allowance pattern\n    uint256 currentAllowance = IERC20Like(labsToken).allowance(address(this), address(vault));\n    if (currentAllowance < toDeposit) {\n      // Some ERC20s require zeroing allowance first\n      if (currentAllowance != 0) {\n        if (!IERC20Like(labsToken).approve(address(vault), 0)) revert TransferFailed();\n      }\n      if (!IERC20Like(labsToken).approve(address(vault), toDeposit)) revert TransferFailed();\n    }\n    \n    // Deposit to vault and receive shares\n    sharesOut = vault.depositLABS(toDeposit, receiver);\n    \n    // Slippage protection\n    if (sharesOut < minSharesOut) revert SlippageExceeded();\n    \n    emit Purchased(msg.sender, labsAmount, sharesOut, fee, pol);\n  }\n\n  function buyFrom(address buyer, uint256 labsAmount, address receiver, uint256 minSharesOut) external nonReentrant whenNotPaused returns (uint256 sharesOut) {\n    if (labsAmount == 0) revert InvalidAmount();\n    if (buyer == address(0) || receiver == address(0)) revert InvalidAddress();\n    \n    // Validate price before purchase\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n    \n    uint256 fee = (labsAmount * feeBps) / BPS_DENOMINATOR;\n    uint256 pol = (labsAmount * polBps) / BPS_DENOMINATOR;\n    uint256 toDeposit = labsAmount - fee - pol;\n\n    // Transfer tokens from buyer\n    if (!IERC20Like(labsToken).transferFrom(buyer, address(this), labsAmount)) {\n      revert TransferFailed();\n    }\n    \n    // Distribute fee to treasury\n    if (fee > 0 && !IERC20Like(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n    // Route POL to treasury as well\n    if (pol > 0 && !IERC20Like(labsToken).transfer(treasury, pol)) {\n      revert TransferFailed();\n    }\n    \n    // Approve vault to spend tokens using robust allowance pattern\n    uint256 currentAllowance = IERC20Like(labsToken).allowance(address(this), address(vault));\n    if (currentAllowance < toDeposit) {\n      if (currentAllowance != 0) {\n        if (!IERC20Like(labsToken).approve(address(vault), 0)) revert TransferFailed();\n      }\n      if (!IERC20Like(labsToken).approve(address(vault), toDeposit)) revert TransferFailed();\n    }\n    \n    // Deposit to vault and receive shares\n    sharesOut = vault.depositLABS(toDeposit, receiver);\n    \n    // Slippage protection\n    if (sharesOut < minSharesOut) revert SlippageExceeded();\n    \n    emit Purchased(buyer, labsAmount, sharesOut, fee, pol);\n  }\n\n  /// @notice Emergency pause of bonding curve operations\n  /// @dev Only callable by admin to halt trading in security incidents\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause bonding curve operations\n  /// @dev Only callable by admin after security incident is resolved\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  /// @return True if paused, false otherwise\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  /// @notice Updates the admin address\n  /// @dev Only callable by current admin\n  /// @param newAdmin Address of new admin\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n}\n\n\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}