{"language":"Solidity","sources":{"contracts/facets/DataValidationFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\n\n/// @title DataValidationFacet\n/// @notice Handles data creation, validation, and proof of provenance with human supervision\n/// @dev Implements on-chain data validation with attribution tracking and human oversight\ncontract DataValidationFacet {\n  // ============ Constants ============\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private constant STATUS_PENDING = 0;\n  uint256 private constant STATUS_APPROVED = 1;\n  uint256 private constant STATUS_REJECTED = 2;\n\n  // ============ Events ============\n  event DataCreated(\n    uint256 indexed dataId,\n    uint256 indexed labId,\n    address indexed creator,\n    bytes32 dataHash,\n    string domain,\n    address baseModel,\n    uint256 timestamp\n  );\n\n  event DataSubmittedForReview(\n    uint256 indexed dataId,\n    address indexed supervisor,\n    uint256 timestamp\n  );\n\n  event DataApproved(\n    uint256 indexed dataId,\n    address indexed supervisor,\n    bytes32 approvalSignature,\n    uint256 timestamp\n  );\n\n  event DataRejected(\n    uint256 indexed dataId,\n    address indexed supervisor,\n    string reason,\n    uint256 timestamp\n  );\n\n  event ProvenanceRecorded(\n    uint256 indexed dataId,\n    address indexed creator,\n    address indexed supervisor,\n    bytes32 contentHash,\n    uint256 deltaGainScore,\n    uint256 timestamp\n  );\n\n  event CredentialLinked(\n    uint256 indexed dataId,\n    uint256 indexed creatorCredentialId,\n    uint256 indexed supervisorCredentialId,\n    uint256 timestamp\n  );\n\n  // ============ Errors ============\n  error ReentrancyGuard();\n  error InvalidLabId();\n  error InvalidDataId();\n  error InvalidAddress();\n  error Unauthorized();\n  error InvalidStatus();\n  error InvalidGainScore();\n  error DataAlreadyExists();\n  error InvalidCredential();\n  error UnverifiedCredential();\n\n  // ============ Modifiers ============\n  modifier nonReentrant() {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    if (hs.reentrancyStatus == ENTERED) revert ReentrancyGuard();\n    hs.reentrancyStatus = ENTERED;\n    _;\n    hs.reentrancyStatus = NOT_ENTERED;\n  }\n\n  modifier onlyLabOwner(uint256 labId) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.Lab storage lab = hs.labs[labId];\n    if (msg.sender != lab.owner) revert Unauthorized();\n    _;\n  }\n\n  // ============ Core Functions ============\n\n  /// @notice Create a new dataset with proof of provenance (with credential linking)\n  /// @dev Initializes data entry with creator, hash, base model, and creator's credential\n  /// @param labId The lab identifier\n  /// @param dataHash The content hash of the dataset (IPFS/Arweave)\n  /// @param domain The data domain (e.g., \"medical\", \"research\", \"synthetic\")\n  /// @param baseModel The address or identifier of the base model used\n  /// @param creatorCredentialId Optional credential ID for creator verification\n  /// @return dataId The unique identifier for this dataset\n  function createData(\n    uint256 labId,\n    bytes32 dataHash,\n    string calldata domain,\n    address baseModel,\n    uint256 creatorCredentialId\n  ) external returns (uint256 dataId) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.Lab storage lab = hs.labs[labId];\n    \n    if (lab.owner == address(0)) revert InvalidLabId();\n    if (baseModel == address(0)) revert InvalidAddress();\n    if (dataHash == bytes32(0)) revert InvalidDataId();\n\n    // Verify creator credential if provided\n    if (creatorCredentialId > 0) {\n      LibH1Storage.Credential storage cred = hs.credentials[creatorCredentialId];\n      if (cred.credentialId == 0) revert InvalidCredential();\n      if (cred.holder != msg.sender) revert Unauthorized();\n      if (cred.status != 1) revert UnverifiedCredential(); // 1 = VERIFIED\n    }\n\n    // Generate unique dataId\n    dataId = hs.nextDataId++;\n\n    // Store data provenance\n    LibH1Storage.DataRecord storage record = hs.dataRecords[dataId];\n    record.creator = msg.sender;\n    record.labId = labId;\n    record.dataHash = dataHash;\n    record.domain = domain;\n    record.baseModel = baseModel;\n    record.status = STATUS_PENDING;\n    record.createdAt = block.timestamp;\n    record.deltaGainScore = 0;\n\n    // Add to lab's data list\n    hs.labDataRecords[labId].push(dataId);\n\n    emit DataCreated(\n      dataId,\n      labId,\n      msg.sender,\n      dataHash,\n      domain,\n      baseModel,\n      block.timestamp\n    );\n\n    // Emit credential link if provided\n    if (creatorCredentialId > 0) {\n      emit CredentialLinked(dataId, creatorCredentialId, 0, block.timestamp);\n    }\n  }\n\n  /// @notice Submit data for human supervisor review with credential requirement\n  /// @dev Marks data as pending review; supervisor must have verified credential in domain\n  /// @param dataId The dataset identifier\n  /// @param supervisor The credentialed human who will review\n  /// @param supervisorCredentialId The credential ID proving supervisor's expertise\n  function submitForReview(\n    uint256 dataId, \n    address supervisor,\n    uint256 supervisorCredentialId\n  ) \n    external \n    nonReentrant \n  {\n    if (supervisor == address(0)) revert InvalidAddress();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.DataRecord storage record = hs.dataRecords[dataId];\n\n    if (record.creator == address(0)) revert InvalidDataId();\n    if (msg.sender != record.creator) revert Unauthorized();\n    if (record.status != STATUS_PENDING) revert InvalidStatus();\n\n    // Verify supervisor has a verified credential in the data's domain\n    LibH1Storage.Credential storage superCred = hs.credentials[supervisorCredentialId];\n    if (superCred.credentialId == 0) revert InvalidCredential();\n    if (superCred.holder != supervisor) revert Unauthorized();\n    if (superCred.status != 1) revert UnverifiedCredential(); // 1 = VERIFIED\n    if (keccak256(abi.encodePacked(superCred.domain)) != keccak256(abi.encodePacked(record.domain))) {\n      revert Unauthorized(); // Supervisor not credentialed in this domain\n    }\n\n    record.pendingSupervisor = supervisor;\n\n    emit DataSubmittedForReview(dataId, supervisor, block.timestamp);\n  }\n\n  /// @notice Supervisor approves the dataset with delta-gain and credential recording\n  /// @dev Records approval signature, delta-gain score, and links credential for audit trail\n  /// @param dataId The dataset identifier\n  /// @param deltaGainScore The improvement score vs base model (0-100 basis points)\n  /// @param approvalSignature The supervisor's signature hash for verification\n  function approveData(\n    uint256 dataId,\n    uint256 deltaGainScore,\n    bytes32 approvalSignature\n  ) external {\n    if (deltaGainScore > 10000) revert InvalidGainScore(); // Max 100%\n\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.DataRecord storage record = hs.dataRecords[dataId];\n\n    if (record.creator == address(0)) revert InvalidDataId();\n    if (msg.sender != record.pendingSupervisor) revert Unauthorized();\n    if (record.status != STATUS_PENDING) revert InvalidStatus();\n\n    // Update record with supervision metadata\n    record.supervisor = msg.sender;\n    record.status = STATUS_APPROVED;\n    record.approvalSignature = approvalSignature;\n    record.deltaGainScore = deltaGainScore;\n    record.approvedAt = block.timestamp;\n\n    // Record attribution for revenue splits\n    hs.attributionRecords[dataId] = LibH1Storage.Attribution({\n      creator: record.creator,\n      supervisor: msg.sender,\n      labId: record.labId,\n      deltaGainScore: deltaGainScore,\n      revenueShare: 0, // Calculated at sale time\n      recordedAt: block.timestamp\n    });\n\n    emit DataApproved(dataId, msg.sender, approvalSignature, block.timestamp);\n    emit ProvenanceRecorded(\n      dataId,\n      record.creator,\n      msg.sender,\n      record.dataHash,\n      deltaGainScore,\n      block.timestamp\n    );\n  }\n\n  /// @notice Supervisor rejects the dataset with reason\n  /// @dev Marks dataset as rejected; creator can iterate and resubmit\n  /// @param dataId The dataset identifier\n  /// @param reason The reason for rejection (stored off-chain via event)\n  function rejectData(uint256 dataId, string calldata reason) external {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.DataRecord storage record = hs.dataRecords[dataId];\n\n    if (record.creator == address(0)) revert InvalidDataId();\n    if (msg.sender != record.pendingSupervisor) revert Unauthorized();\n    if (record.status != STATUS_PENDING) revert InvalidStatus();\n\n    record.status = STATUS_REJECTED;\n    record.supervisor = msg.sender;\n\n    emit DataRejected(dataId, msg.sender, reason, block.timestamp);\n  }\n\n  // ============ View Functions ============\n\n  /// @notice Get the full provenance record for a dataset\n  /// @param dataId The dataset identifier\n  /// @return The complete data record with all metadata\n  function getDataRecord(uint256 dataId) \n    external \n    view \n    returns (LibH1Storage.DataRecord memory) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    return hs.dataRecords[dataId];\n  }\n\n  /// @notice Get attribution record for revenue distribution\n  /// @param dataId The dataset identifier\n  /// @return The attribution with creator, supervisor, and delta-gain score\n  function getAttribution(uint256 dataId) \n    external \n    view \n    returns (LibH1Storage.Attribution memory) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    return hs.attributionRecords[dataId];\n  }\n\n  /// @notice Get all approved data for a lab\n  /// @param labId The lab identifier\n  /// @return Array of approved data IDs for this lab\n  function getLabApprovedData(uint256 labId) \n    external \n    view \n    returns (uint256[] memory) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    uint256[] storage allData = hs.labDataRecords[labId];\n    \n    // Count approved records\n    uint256 count = 0;\n    for (uint256 i = 0; i < allData.length; i++) {\n      if (hs.dataRecords[allData[i]].status == STATUS_APPROVED) {\n        count++;\n      }\n    }\n\n    // Build array of approved\n    uint256[] memory approved = new uint256[](count);\n    uint256 idx = 0;\n    for (uint256 i = 0; i < allData.length; i++) {\n      if (hs.dataRecords[allData[i]].status == STATUS_APPROVED) {\n        approved[idx++] = allData[i];\n      }\n    }\n    return approved;\n  }\n\n  /// @notice Get all data records for a lab\n  /// @param labId The lab identifier\n  /// @return Array of all data IDs for this lab\n  function getLabData(uint256 labId) \n    external \n    view \n    returns (uint256[] memory) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    return hs.labDataRecords[labId];\n  }\n\n  /// @notice Get data record status\n  /// @param dataId The dataset identifier\n  /// @return status 0=PENDING, 1=APPROVED, 2=REJECTED\n  function getDataStatus(uint256 dataId) \n    external \n    view \n    returns (uint256 status) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    return hs.dataRecords[dataId].status;\n  }\n}\n"},"contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}