{"language":"Solidity","sources":{"contracts/contracts/facets/LabPassFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\nimport { LabPass } from \"../tokens/LabPass.sol\";\n\ncontract LabPassFacet {\n  event LabPassDeployed(uint256 indexed labId, address labPass);\n  event LabPassMinted(uint256 indexed labId, uint256 tokenId, address indexed to, uint8 level, uint8 slots);\n\n  error Unauthorized();\n  error InvalidAddress();\n  error LabPassAlreadyExists();\n  error LabPassNotDeployed();\n  error InvalidLabId();\n  error InvalidLevel();\n  error InvalidSlots();\n\n  function deployLabPass(uint256 labId) public returns (address pass) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    if (hs.labs[labId].owner == address(0)) revert InvalidLabId();\n    if (hs.labs[labId].owner != msg.sender) revert Unauthorized();\n    if (hs.labIdToLabPass[labId] != address(0)) revert LabPassAlreadyExists();\n    \n    pass = address(new LabPass());\n    hs.labIdToLabPass[labId] = pass;\n    \n    // Set the facet as the minter\n    LabPass(pass).setMinter(address(this));\n    \n    emit LabPassDeployed(labId, pass);\n  }\n\n  function mintLabPass(uint256 labId, uint256 tokenId, address to, uint8 level, uint8 slots) external {\n    if (to == address(0)) revert InvalidAddress();\n    if (level > 10) revert InvalidLevel();\n    if (slots > 10) revert InvalidSlots();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    if (hs.labs[labId].owner != msg.sender) revert Unauthorized();\n    \n    address pass = hs.labIdToLabPass[labId];\n    if (pass == address(0)) revert LabPassNotDeployed();\n    \n    LabPass(pass).mint(to, tokenId, level, slots);\n    emit LabPassMinted(labId, tokenId, to, level, slots);\n  }\n  \n  function getLabPass(uint256 labId) external view returns (address) {\n    return LibH1Storage.h1Storage().labIdToLabPass[labId];\n  }\n}\n\n\n"},"contracts/contracts/tokens/LabPass.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC165 { function supportsInterface(bytes4 interfaceId) external view returns (bool); }\n\ninterface IERC721Receiver {\n  function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\ninterface IERC721 is IERC165 {\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n  function balanceOf(address owner) external view returns (uint256);\n  function ownerOf(uint256 tokenId) external view returns (address);\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\n  function transferFrom(address from, address to, uint256 tokenId) external;\n  function approve(address to, uint256 tokenId) external;\n  function getApproved(uint256 tokenId) external view returns (address);\n  function setApprovalForAll(address operator, bool approved) external;\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n/// @title LabPass NFT\n/// @notice ERC-721 NFT representing lab membership with level and app slot metadata\n/// @dev Implements soulbound token functionality with admin-controlled transferability\ncontract LabPass is IERC721 {\n  string public name = \"LabPass\";\n  string public symbol = \"LBP\";\n  bool public transferable;\n  address public minter;\n  address public admin;\n\n  struct PassData { uint8 level; uint8 appSlots; }\n\n  mapping(uint256 => address) private _ownerOf;\n  mapping(address => uint256) private _balanceOf;\n  mapping(uint256 => address) private _approvals;\n  mapping(address => mapping(address => bool)) private _operatorApproval;\n  mapping(uint256 => PassData) public passData;\n\n  event TransferabilitySet(bool transferable);\n  event MinterUpdated(address indexed newMinter);\n  event AdminUpdated(address indexed newAdmin);\n\n  error Unauthorized();\n  error TokenNotFound();\n  error InvalidAddress();\n  error InvalidApproval();\n  error TokenAlreadyExists();\n  error UnsafeRecipient();\n\n  constructor() {\n    admin = msg.sender;\n    minter = msg.sender;\n  }\n\n  modifier onlyMinter() {\n    if (msg.sender != minter) revert Unauthorized();\n    _;\n  }\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == 0x80ac58cd || interfaceId == 0x01ffc9a7;\n  }\n\n  function balanceOf(address owner) external view override returns (uint256) { \n    if (owner == address(0)) revert InvalidAddress();\n    return _balanceOf[owner]; \n  }\n  \n  function ownerOf(uint256 tokenId) public view override returns (address) { \n    address owner = _ownerOf[tokenId];\n    if (owner == address(0)) revert TokenNotFound();\n    return owner; \n  }\n  \n  function getApproved(uint256 tokenId) external view override returns (address) { \n    if (_ownerOf[tokenId] == address(0)) revert TokenNotFound();\n    return _approvals[tokenId]; \n  }\n  \n  function isApprovedForAll(address owner, address operator) external view override returns (bool) { \n    return _operatorApproval[owner][operator]; \n  }\n\n  function setMinter(address newMinter) external onlyAdmin {\n    if (newMinter == address(0)) revert InvalidAddress();\n    minter = newMinter;\n    emit MinterUpdated(newMinter);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n\n  function setTransferable(bool t) external onlyAdmin { \n    transferable = t; \n    emit TransferabilitySet(t); \n  }\n\n  /// @notice Mints a single LabPass NFT\n  /// @param to The address to mint the token to\n  /// @param tokenId The unique identifier for the token\n  /// @param level The membership level (0-10)\n  /// @param slots The number of app slots (0-10)\n  function mint(address to, uint256 tokenId, uint8 level, uint8 slots) external onlyMinter {\n    if (to == address(0)) revert InvalidAddress();\n    if (_ownerOf[tokenId] != address(0)) revert TokenAlreadyExists();\n    if (level > 10) revert InvalidApproval(); // Max level 10\n    if (slots > 10) revert InvalidApproval(); // Max slots 10\n    \n    _ownerOf[tokenId] = to;\n    unchecked { _balanceOf[to] += 1; } // Safe: balance won't overflow\n    passData[tokenId] = PassData({ level: level, appSlots: slots });\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /// @notice Batch mints multiple LabPass NFTs (gas optimized)\n  /// @param recipients Array of addresses to mint tokens to\n  /// @param tokenIds Array of unique token identifiers\n  /// @param levels Array of membership levels\n  /// @param slots Array of app slots\n  function batchMint(\n    address[] calldata recipients,\n    uint256[] calldata tokenIds,\n    uint8[] calldata levels,\n    uint8[] calldata slots\n  ) external onlyMinter {\n    uint256 length = recipients.length;\n    if (length != tokenIds.length || length != levels.length || length != slots.length) {\n      revert InvalidApproval();\n    }\n    \n    for (uint256 i; i < length; ) {\n      address to = recipients[i];\n      uint256 tokenId = tokenIds[i];\n      uint8 level = levels[i];\n      uint8 slot = slots[i];\n      \n      if (to == address(0)) revert InvalidAddress();\n      if (_ownerOf[tokenId] != address(0)) revert TokenAlreadyExists();\n      if (level > 10 || slot > 10) revert InvalidApproval();\n      \n      _ownerOf[tokenId] = to;\n      unchecked { _balanceOf[to] += 1; } // Safe: balance won't overflow\n      passData[tokenId] = PassData({ level: level, appSlots: slot });\n      emit Transfer(address(0), to, tokenId);\n      \n      unchecked { ++i; }\n    }\n  }\n\n  function setLevel(uint256 tokenId, uint8 level, uint8 slots) external onlyAdmin { \n    if (_ownerOf[tokenId] == address(0)) revert TokenNotFound();\n    if (level > 10) revert InvalidApproval();\n    if (slots > 10) revert InvalidApproval();\n    passData[tokenId].level = level; \n    passData[tokenId].appSlots = slots; \n  }\n\n  function approve(address to, uint256 tokenId) external override { \n    address owner = ownerOf(tokenId);\n    if (msg.sender != owner && !_operatorApproval[owner][msg.sender]) revert Unauthorized();\n    _approvals[tokenId] = to; \n    emit Approval(owner, to, tokenId); \n  }\n\n  function setApprovalForAll(address operator, bool approved) external override { \n    if (operator == address(0)) revert InvalidAddress();\n    _operatorApproval[msg.sender][operator] = approved; \n    emit ApprovalForAll(msg.sender, operator, approved); \n  }\n\n  function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n    address owner = ownerOf(tokenId);\n    return (spender == owner || _approvals[tokenId] == spender || _operatorApproval[owner][spender]);\n  }\n\n  function transferFrom(address from, address to, uint256 tokenId) public override {\n    if (!transferable) revert Unauthorized();\n    if (!_isApprovedOrOwner(msg.sender, tokenId)) revert Unauthorized();\n    if (ownerOf(tokenId) != from) revert Unauthorized();\n    if (to == address(0)) revert InvalidAddress();\n    \n    delete _approvals[tokenId];\n    _balanceOf[from] -= 1;\n    _balanceOf[to] += 1;\n    _ownerOf[tokenId] = to;\n    emit Transfer(from, to, tokenId);\n  }\n\n  function safeTransferFrom(address from, address to, uint256 tokenId) external override { \n    transferFrom(from, to, tokenId); \n    _checkOnERC721Received(from, to, tokenId, \"\");\n  }\n\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external override { \n    transferFrom(from, to, tokenId);\n    _checkOnERC721Received(from, to, tokenId, data);\n  }\n\n  function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n    if (to.code.length > 0) {\n      try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\n        if (retval != IERC721Receiver.onERC721Received.selector) revert UnsafeRecipient();\n      } catch {\n        revert UnsafeRecipient();\n      }\n    }\n  }\n}\n\n\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}