{"language":"Solidity","sources":{"contracts/facets/CredentialFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\n\n/// @title CredentialFacet\n/// @notice Manages user credentials, verification, and identity for the H1 Labs protocol\n/// @dev Enables off-chain verified credentials to be tracked on-chain for provenance\ncontract CredentialFacet {\n  // ============ Constants ============\n  uint256 private constant CREDENTIAL_PENDING = 0;\n  uint256 private constant CREDENTIAL_VERIFIED = 1;\n  uint256 private constant CREDENTIAL_REVOKED = 2;\n  \n  // ============ Events ============\n  event CredentialIssued(\n    uint256 indexed credentialId,\n    address indexed holder,\n    address indexed issuer,\n    string credentialType,\n    string domain,\n    bytes32 offChainVerificationHash,\n    uint256 timestamp\n  );\n\n  event CredentialVerified(\n    uint256 indexed credentialId,\n    address indexed verifier,\n    string verificationDetails,\n    uint256 timestamp\n  );\n\n  event CredentialRevoked(\n    uint256 indexed credentialId,\n    address indexed revoker,\n    string reason,\n    uint256 timestamp\n  );\n\n  event CredentialMetadataUpdated(\n    uint256 indexed credentialId,\n    string newMetadata,\n    uint256 timestamp\n  );\n\n  event UserIdCreated(\n    address indexed user,\n    uint256 indexed userId,\n    string domainFocus,\n    uint256 timestamp\n  );\n\n  // ============ Errors ============\n  error InvalidCredentialId();\n  error InvalidUserId();\n  error InvalidAddress();\n  error InvalidStatus();\n  error Unauthorized();\n  error CredentialAlreadyExists();\n  error InvalidCredentialType();\n  error InvalidDomain();\n\n  // ============ Core Functions ============\n\n  /// @notice Create a unique user ID with credential tracking\n  /// @dev Generates a userId for a user and initializes their credential history\n  /// @param user The address to create an ID for\n  /// @param domainFocus The primary domain focus (e.g., \"medical\", \"finance\", \"research\")\n  /// @return userId The unique identifier for this user\n  function createUserId(\n    address user,\n    string calldata domainFocus\n  ) external returns (uint256 userId) {\n    if (user == address(0)) revert InvalidAddress();\n    if (bytes(domainFocus).length == 0) revert InvalidDomain();\n\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    // Check user doesn't already have an ID\n    if (hs.userAddressToId[user] != 0) revert CredentialAlreadyExists();\n\n    // Generate new userId\n    userId = ++hs.nextUserId;\n    \n    // Store mapping\n    hs.userAddressToId[user] = userId;\n    hs.userIdToAddress[userId] = user;\n    \n    // Create user profile\n    hs.userProfiles[userId] = LibH1Storage.UserProfile({\n      userAddress: user,\n      domainFocus: domainFocus,\n      createdAt: block.timestamp,\n      credentialCount: 0,\n      verifiedCredentialCount: 0,\n      isActive: true\n    });\n\n    emit UserIdCreated(user, userId, domainFocus, block.timestamp);\n  }\n\n  /// @notice Issue a credential to a user (off-chain verified)\n  /// @dev Issuer can be an organization, institution, or credentialing body\n  /// @param userId The user receiving the credential\n  /// @param credentialType The type of credential (e.g., \"physician\", \"ml-engineer\", \"data-scientist\")\n  /// @param domain The domain of expertise (e.g., \"medical\", \"research\", \"finance\")\n  /// @param offChainVerificationHash Hash of off-chain verification document (IPFS/Arweave)\n  /// @return credentialId The unique credential identifier\n  function issueCredential(\n    uint256 userId,\n    string calldata credentialType,\n    string calldata domain,\n    bytes32 offChainVerificationHash\n  ) external returns (uint256 credentialId) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    if (hs.userIdToAddress[userId] == address(0)) revert InvalidUserId();\n    if (bytes(credentialType).length == 0) revert InvalidCredentialType();\n    if (bytes(domain).length == 0) revert InvalidDomain();\n    if (offChainVerificationHash == bytes32(0)) revert InvalidCredentialId();\n    \n    // Generate credentialId\n    credentialId = ++hs.nextCredentialId;\n\n    // Store credential\n    hs.credentials[credentialId] = LibH1Storage.Credential({\n      credentialId: credentialId,\n      holder: hs.userIdToAddress[userId],\n      userId: userId,\n      issuer: msg.sender,\n      credentialType: credentialType,\n      domain: domain,\n      status: CREDENTIAL_PENDING,\n      offChainVerificationHash: offChainVerificationHash,\n      issuedAt: block.timestamp,\n      verifiedAt: 0,\n      revokedAt: 0\n    });\n\n    // Add to user's credentials\n    hs.userCredentials[userId].push(credentialId);\n    \n    // Increment user's credential count\n    LibH1Storage.UserProfile storage profile = hs.userProfiles[userId];\n    profile.credentialCount++;\n\n    emit CredentialIssued(\n      credentialId,\n      hs.userIdToAddress[userId],\n      msg.sender,\n      credentialType,\n      domain,\n      offChainVerificationHash,\n      block.timestamp\n    );\n  }\n\n  /// @notice Verify a credential (marks it as verified)\n  /// @dev Can be called by issuer or designated verifier\n  /// @param credentialId The credential to verify\n  /// @param verificationDetails Details of verification (stored in events)\n  function verifyCredential(\n    uint256 credentialId,\n    string calldata verificationDetails\n  ) external {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.Credential storage cred = hs.credentials[credentialId];\n\n    if (cred.credentialId == 0) revert InvalidCredentialId();\n    if (cred.issuer != msg.sender) revert Unauthorized();\n    if (cred.status != CREDENTIAL_PENDING) revert InvalidStatus();\n\n    // Mark as verified\n    cred.status = CREDENTIAL_VERIFIED;\n    cred.verifiedAt = block.timestamp;\n\n    // Increment user's verified count\n    LibH1Storage.UserProfile storage profile = hs.userProfiles[cred.userId];\n    profile.verifiedCredentialCount++;\n\n    emit CredentialVerified(credentialId, msg.sender, verificationDetails, block.timestamp);\n  }\n\n  /// @notice Revoke a credential\n  /// @dev Only issuer can revoke\n  /// @param credentialId The credential to revoke\n  /// @param reason Reason for revocation (stored in events)\n  function revokeCredential(\n    uint256 credentialId,\n    string calldata reason\n  ) external {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.Credential storage cred = hs.credentials[credentialId];\n\n    if (cred.credentialId == 0) revert InvalidCredentialId();\n    if (cred.issuer != msg.sender) revert Unauthorized();\n    if (cred.status == CREDENTIAL_REVOKED) revert InvalidStatus();\n\n    // Mark as revoked\n    cred.status = CREDENTIAL_REVOKED;\n    cred.revokedAt = block.timestamp;\n\n    // Decrement verified count if was verified\n    if (cred.verifiedAt > 0) {\n      LibH1Storage.UserProfile storage profile = hs.userProfiles[cred.userId];\n      if (profile.verifiedCredentialCount > 0) {\n        profile.verifiedCredentialCount--;\n      }\n    }\n\n    emit CredentialRevoked(credentialId, msg.sender, reason, block.timestamp);\n  }\n\n  // ============ View Functions ============\n\n  /// @notice Get user ID from address\n  /// @param user The user address\n  /// @return userId The user's unique ID (0 if not created)\n  function getUserId(address user) external view returns (uint256) {\n    return LibH1Storage.h1Storage().userAddressToId[user];\n  }\n\n  /// @notice Get user address from ID\n  /// @param userId The user ID\n  /// @return userAddress The address associated with this ID\n  function getUserAddress(uint256 userId) external view returns (address) {\n    return LibH1Storage.h1Storage().userIdToAddress[userId];\n  }\n\n  /// @notice Get full credential record\n  /// @param credentialId The credential ID\n  /// @return The credential record\n  function getCredential(uint256 credentialId) \n    external \n    view \n    returns (LibH1Storage.Credential memory) \n  {\n    return LibH1Storage.h1Storage().credentials[credentialId];\n  }\n\n  /// @notice Get user profile\n  /// @param userId The user ID\n  /// @return The user profile with credential counts\n  function getUserProfile(uint256 userId) \n    external \n    view \n    returns (LibH1Storage.UserProfile memory) \n  {\n    return LibH1Storage.h1Storage().userProfiles[userId];\n  }\n\n  /// @notice Get all credentials for a user\n  /// @param userId The user ID\n  /// @return Array of credential IDs for this user\n  function getUserCredentials(uint256 userId) \n    external \n    view \n    returns (uint256[] memory) \n  {\n    return LibH1Storage.h1Storage().userCredentials[userId];\n  }\n\n  /// @notice Get verified credentials for a user\n  /// @param userId The user ID\n  /// @return Array of verified credential IDs\n  function getVerifiedCredentials(uint256 userId) \n    external \n    view \n    returns (uint256[] memory) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    uint256[] storage allCredentials = hs.userCredentials[userId];\n    \n    // Count verified credentials\n    uint256 count = 0;\n    for (uint256 i = 0; i < allCredentials.length; i++) {\n      if (hs.credentials[allCredentials[i]].status == CREDENTIAL_VERIFIED) {\n        count++;\n      }\n    }\n\n    // Build array of verified\n    uint256[] memory verified = new uint256[](count);\n    uint256 idx = 0;\n    for (uint256 i = 0; i < allCredentials.length; i++) {\n      if (hs.credentials[allCredentials[i]].status == CREDENTIAL_VERIFIED) {\n        verified[idx++] = allCredentials[i];\n      }\n    }\n    return verified;\n  }\n\n  /// @notice Check if user has a verified credential in a domain\n  /// @param userId The user ID\n  /// @param domain The domain to check (e.g., \"medical\", \"finance\")\n  /// @return hasVerified True if user has at least one verified credential in domain\n  function hasVerifiedCredentialInDomain(uint256 userId, string calldata domain) \n    external \n    view \n    returns (bool) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    uint256[] storage credentials = hs.userCredentials[userId];\n    \n    for (uint256 i = 0; i < credentials.length; i++) {\n      LibH1Storage.Credential storage cred = hs.credentials[credentials[i]];\n      if (\n        cred.status == CREDENTIAL_VERIFIED &&\n        keccak256(abi.encodePacked(cred.domain)) == keccak256(abi.encodePacked(domain))\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @notice Get credential status\n  /// @param credentialId The credential ID\n  /// @return status 0=PENDING, 1=VERIFIED, 2=REVOKED\n  function getCredentialStatus(uint256 credentialId) \n    external \n    view \n    returns (uint256) \n  {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    return hs.credentials[credentialId].status;\n  }\n}\n\n"},"contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}