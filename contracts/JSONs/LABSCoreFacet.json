{"language":"Solidity","sources":{"contracts/facets/LABSCoreFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\nimport { LibLabVaultFactory } from \"../libraries/LibLabVaultFactory.sol\";\n\ninterface IERC20 {\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n/// @title LABSCoreFacet\n/// @notice Core functionality for lab creation and LABS token staking\n/// @dev Diamond facet for H1 Labs platform core operations\ncontract LABSCoreFacet {\n  event LabCreated(uint256 indexed labId, address indexed owner, string name, string symbol, string domain, address h1Token);\n  event VaultDeployed(uint256 indexed labId, address indexed vault, uint64 cooldownSeconds, uint16 exitCapBps);\n  event Staked(address indexed staker, uint256 amount);\n\n  error InvalidString();\n  error InvalidAmount();\n  error DomainAlreadyExists();\n  error LabsTokenNotSet();\n  error TransferFailed();\n\n  // NOTE: storage moved to LibH1Storage to avoid diamond storage collisions\n\n  /// @notice Stakes LABS tokens to earn LabSlot NFT eligibility\n  /// @dev Transfers LABS tokens from user and tracks staked balance\n  /// @param amount Amount of LABS tokens to stake (must be > 0)\n  function stakeLABS(uint256 amount) external {\n    if (amount == 0) revert InvalidAmount();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    if (hs.labsToken == address(0)) revert LabsTokenNotSet();\n    \n    // Transfer LABS tokens from user to this contract using proper ERC-20 interface\n    require(\n      IERC20(hs.labsToken).transferFrom(msg.sender, address(this), amount),\n      \"TransferFailed\"\n    );\n    \n    // Track staked balance\n    unchecked {\n      LibH1Storage.h1Storage().stakedBalances[msg.sender] += amount; // Safe: overflow unlikely with real token amounts\n    }\n    \n    emit Staked(msg.sender, amount);\n    \n    // Note: LabSlot NFT minting logic to be added in separate facet/upgrade\n  }\n\n  function createLab(string calldata name, string calldata symbol, string calldata domain) external returns (uint256 labId) {\n    // Input validation\n    if (bytes(name).length == 0 || bytes(name).length > 50) revert InvalidString();\n    if (bytes(symbol).length == 0 || bytes(symbol).length > 10) revert InvalidString();\n    if (bytes(domain).length == 0 || bytes(domain).length > 100) revert InvalidString();\n    bytes32 domainKey = keccak256(bytes(domain));\n    if (LibH1Storage.h1Storage().domainTaken[domainKey]) revert DomainAlreadyExists();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    if (hs.labsToken == address(0)) revert LabsTokenNotSet();\n    \n    labId = hs.nextLabId++;\n    hs.labs[labId].owner = msg.sender;\n    hs.labs[labId].domain = domain;\n    hs.labs[labId].active = true;\n    hs.domainTaken[domainKey] = true;\n\n    // Auto-deploy LabVault (ERC-4626-style shares as H1 token)\n    address vault = LibLabVaultFactory.deployVault(\n      hs.labsToken,\n      name,\n      symbol,\n      name,\n      hs.defaultCooldown,\n      hs.defaultExitCapBps,\n      msg.sender,\n      msg.sender,\n      hs.protocolTreasury\n    );\n    hs.labIdToVault[labId] = vault;\n    hs.labs[labId].h1Token = vault;\n\n    emit LabCreated(labId, msg.sender, name, symbol, domain, vault);\n    emit VaultDeployed(labId, vault, hs.defaultCooldown, hs.defaultExitCapBps);\n  }\n  \n  function isDomainAvailable(string calldata domain) external view returns (bool) {\n    bytes32 domainKey = keccak256(bytes(domain));\n    return !LibH1Storage.h1Storage().domainTaken[domainKey];\n  }\n}"},"contracts/libraries/LibLabVaultFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LabVault } from \"../vaults/LabVault.sol\";\n\n/// @title LibLabVaultFactory\n/// @notice Library for deploying LabVault contracts\n/// @dev Separates deployment logic to reduce facet contract size\nlibrary LibLabVaultFactory {\n  /// @notice Deploys a new LabVault contract\n  /// @param labsToken The LABS token address\n  /// @param h1Name The H1 token name\n  /// @param h1Symbol The H1 token symbol\n  /// @param labDisplayName The lab display name\n  /// @param cooldownSeconds Cooldown period for redemptions\n  /// @param epochExitCapBps Exit cap in basis points\n  /// @param admin Admin address for the vault\n  /// @param labOwner Lab owner address for fee distribution\n  /// @param treasury Treasury address for fee distribution\n  /// @return vault The address of the deployed vault\n  function deployVault(\n    address labsToken,\n    string memory h1Name,\n    string memory h1Symbol,\n    string memory labDisplayName,\n    uint64 cooldownSeconds,\n    uint16 epochExitCapBps,\n    address admin,\n    address labOwner,\n    address treasury\n  ) internal returns (address vault) {\n    vault = address(new LabVault(\n      labsToken,\n      h1Name,\n      h1Symbol,\n      labDisplayName,\n      cooldownSeconds,\n      epochExitCapBps,\n      admin,\n      labOwner,\n      treasury\n    ));\n  }\n}"},"contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"},"contracts/vaults/LabVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC20Base } from \"../tokens/ERC20Base.sol\";\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract LabVault is ERC20Base {\n  address public immutable labsToken;\n  string public labDisplayName;\n  address public admin;\n  address public labOwner;           // New: Lab owner receives 1.5% of fees\n  address public treasury;           // New: H1 treasury receives 1% of fees\n\n  uint256 public constant LEVEL1 = 100_000e18;\n  uint256 public constant LEVEL2 = 250_000e18;\n  uint256 public constant LEVEL3 = 500_000e18;\n  uint16 public constant MAX_EXIT_CAP_BPS = 10_000; // 100%\n  uint16 public constant MAX_TOTAL_FEE_BPS = 250;   // 2.5% max total fee (1.5% + 1%)\n\n  uint64 public cooldownSeconds;\n  uint16 public epochExitCapBps;\n  uint64 public epochStart;\n  \n  // Fee configuration (basis points) - Total: 2.5% (1.5% + 1%)\n  uint16 public depositFeeLabOwnerBps = 150;        // 1.5% to lab owner (default)\n  uint16 public depositFeeTreasuryBps = 100;        // 1% to treasury (default)\n  uint16 public redemptionFeeLabOwnerBps = 150;     // 1.5% to lab owner (default)\n  uint16 public redemptionFeeTreasuryBps = 100;     // 1% to treasury (default)\n\n  uint256 public totalAssets;\n  uint256 public pendingExitAssets;\n  uint256 public epochExitedAssets;\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n\n  modifier nonReentrant() {\n    require(status == NOT_ENTERED, \"reentrancy\");\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  // Optimized struct packing: 2 storage slots instead of 4\n  struct RedeemRequest {\n    address owner;      // 20 bytes\n    uint64 unlockTime;  // 8 bytes  \n    bool claimed;       // 1 byte\n    // Total: 29 bytes in slot 1 (3 bytes padding)\n    uint256 assets;     // 32 bytes in slot 2\n  }\n\n  uint256 public nextRequestId;\n  mapping(uint256 => RedeemRequest) public redeemRequests;\n\n  event Deposited(address indexed caller, address indexed receiver, uint256 assets, uint256 shares);\n  event DepositFeeCollected(address indexed caller, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemRequested(uint256 indexed requestId, address indexed owner, uint256 sharesBurned, uint256 assets, uint64 unlockTime);\n  event RedemptionFeeCollected(uint256 indexed requestId, address indexed owner, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemClaimed(uint256 indexed requestId, address indexed owner, uint256 assets);\n  event RedeemCanceled(uint256 indexed requestId, address indexed owner, uint256 assets, uint256 sharesReMinted);\n  event LevelChanged(uint8 newLevel, uint256 totalAssets);\n  event ExitCapsUpdated(uint64 cooldownSeconds, uint16 epochExitCapBps);\n  event EpochRolled(uint64 newEpochStart);\n  event RedeemFilled(uint256 indexed requestId, address indexed filler, uint256 assets, address receiver);\n  event AdminUpdated(address indexed newAdmin);\n  event LabOwnerUpdated(address indexed newLabOwner);\n  event TreasuryUpdated(address indexed newTreasury);\n  event FeesUpdated(uint16 depositLabOwnerBps, uint16 depositTreasuryBps, uint16 redemptionLabOwnerBps, uint16 redemptionTreasuryBps);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n\n  error Unauthorized();\n  error InvalidAddress();\n  error InvalidAmount();\n  error InvalidParameter();\n  error ContractPaused();\n\n  bool private _paused;\n\n  // Testing variables (TESTNET ONLY)\n  bool public testMode;\n  uint8 public overrideLevel;\n  uint256 public testTimeOffset;\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  constructor(\n    address labsToken_,\n    string memory h1Name_,\n    string memory h1Symbol_,\n    string memory labDisplayName_,\n    uint64 cooldownSeconds_,\n    uint16 epochExitCapBps_,\n    address admin_,\n    address labOwner_,\n    address treasury_\n  ) ERC20Base(h1Name_, h1Symbol_, 18) {\n    require(labsToken_ != address(0), \"labs token = 0\");\n    require(labOwner_ != address(0), \"lab owner = 0\");\n    require(treasury_ != address(0), \"treasury = 0\");\n    require(bytes(h1Name_).length > 0 && bytes(h1Name_).length <= 50, \"invalid name\");\n    require(bytes(h1Symbol_).length > 0 && bytes(h1Symbol_).length <= 10, \"invalid symbol\");\n    require(epochExitCapBps_ <= MAX_EXIT_CAP_BPS, \"exit cap > 100%\");\n    \n    labsToken = labsToken_;\n    labDisplayName = labDisplayName_;\n    cooldownSeconds = cooldownSeconds_;\n    epochExitCapBps = epochExitCapBps_;\n    admin = admin_;\n    labOwner = labOwner_;\n    treasury = treasury_;\n  }\n\n  function assetsPerShare() public view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 1e18;\n    return (totalAssets * 1e18) / supply;\n  }\n\n  function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n    uint256 rate = assetsPerShare();\n    shares = (assets * 1e18) / rate;\n  }\n\n  function previewMint(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  /// @notice Preview deposit accounting for deposit fee\n  function previewDepositWithFee(uint256 assets) public view returns (uint256 shares, uint256 labOwnerFee, uint256 treasuryFee) {\n    labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    shares = previewDeposit(netAssets);\n  }\n\n  /// @notice Preview redemption accounting for redemption fee\n  function previewRedeemWithFee(uint256 shares) public view returns (uint256 assets, uint256 labOwnerFee, uint256 treasuryFee) {\n    assets = previewRedeem(shares);\n    labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n  }\n\n  function getLevel() public view returns (uint8 level) {\n    // If in test mode and override level is set, return it\n    if (testMode && overrideLevel > 0) {\n      return overrideLevel;\n    }\n    \n    // Normal level calculation\n    uint256 a = totalAssets;\n    if (a >= LEVEL3) return 3;\n    if (a >= LEVEL2) return 2;\n    if (a >= LEVEL1) return 1;\n    return 0;\n  }\n\n  function getAppSlots() external view returns (uint8 slots) {\n    uint8 level = getLevel();\n    if (level == 3) return 3;\n    if (level == 2) return 2;\n    if (level == 1) return 1;\n    return 0;\n  }\n\n  function depositLABS(uint256 assets, address receiver) external nonReentrant whenNotPaused returns (uint256 shares) {\n    require(assets > 0, \"zero assets\");\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    \n    shares = previewDeposit(netAssets);\n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), assets), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += netAssets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, netAssets, shares);\n  }\n\n  function mintShares(uint256 shares, address receiver) external nonReentrant whenNotPaused returns (uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewMint(shares);\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 totalRequired = assets + (labOwnerFee + treasuryFee);\n    \n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), totalRequired), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += assets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, assets, shares);\n  }\n\n  function requestRedeem(uint256 shares) external nonReentrant whenNotPaused returns (uint256 requestId, uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewRedeem(shares);\n    \n    // Calculate redemption fees\n    uint256 labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n    \n    _rollEpochIfNeeded();\n    _checkAndAccrueExitCap(assets);\n    _burn(msg.sender, shares);\n    pendingExitAssets += assets;\n    uint64 unlockTime = uint64(_currentTime()) + cooldownSeconds;\n    requestId = ++nextRequestId;\n    redeemRequests[requestId] = RedeemRequest({ owner: msg.sender, assets: assets, unlockTime: unlockTime, claimed: false });\n    emit RedemptionFeeCollected(requestId, msg.sender, labOwnerFee, treasuryFee);\n    emit RedeemRequested(requestId, msg.sender, shares, assets, unlockTime);\n  }\n\n  function cancelRedeem(uint256 requestId) external nonReentrant returns (uint256 shares) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(r.owner == msg.sender, \"not owner\");\n    require(!r.claimed, \"claimed\");\n    uint256 assets = r.assets;\n    delete redeemRequests[requestId];\n    pendingExitAssets -= assets;\n    shares = previewDeposit(assets);\n    _mint(msg.sender, shares);\n    emit RedeemCanceled(requestId, msg.sender, assets, shares);\n  }\n\n  function claimRedeem(uint256 requestId) external nonReentrant {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    require(_currentTime() >= r.unlockTime, \"cooldown\");\n    pendingExitAssets -= r.assets;\n    r.claimed = true;\n    totalAssets -= r.assets;\n    \n    // Calculate and apply fees at claim time\n    uint256 labOwnerFee = (r.assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (r.assets * redemptionFeeTreasuryBps) / 10_000;\n    uint256 netAssets = r.assets - (labOwnerFee + treasuryFee);\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    require(IERC20(labsToken).transfer(r.owner, netAssets), \"transfer fail\");\n    _maybeEmitLevelChange();\n    emit RedeemClaimed(requestId, r.owner, netAssets);\n  }\n\n  function fillRedeem(uint256 requestId, address receiver) external nonReentrant returns (uint256 sharesMinted) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    _rollEpochIfNeeded();\n    uint256 assets = r.assets;\n    require(IERC20(labsToken).transferFrom(msg.sender, r.owner, assets), \"fill xfer fail\");\n    pendingExitAssets -= assets;\n    r.claimed = true;\n    sharesMinted = 0;\n    emit RedeemFilled(requestId, msg.sender, assets, receiver);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n\n  function setLabOwner(address newLabOwner) external onlyAdmin {\n    if (newLabOwner == address(0)) revert InvalidAddress();\n    labOwner = newLabOwner;\n    emit LabOwnerUpdated(newLabOwner);\n  }\n\n  function setTreasury(address newTreasury) external onlyAdmin {\n    if (newTreasury == address(0)) revert InvalidAddress();\n    treasury = newTreasury;\n    emit TreasuryUpdated(newTreasury);\n  }\n\n  /// @notice Set deposit and redemption fees (in basis points)\n  /// @dev Both fees must be <= 100 bps (1%)\n  function setFees(uint16 depositLabOwnerBps_, uint16 depositTreasuryBps_, uint16 redemptionLabOwnerBps_, uint16 redemptionTreasuryBps_) external onlyAdmin {\n    require(depositLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"deposit lab owner fee too high\");\n    require(depositTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"deposit treasury fee too high\");\n    require(redemptionLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"redemption lab owner fee too high\");\n    require(redemptionTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"redemption treasury fee too high\");\n    depositFeeLabOwnerBps = depositLabOwnerBps_;\n    depositFeeTreasuryBps = depositTreasuryBps_;\n    redemptionFeeLabOwnerBps = redemptionLabOwnerBps_;\n    redemptionFeeTreasuryBps = redemptionTreasuryBps_;\n    emit FeesUpdated(depositFeeLabOwnerBps, depositFeeTreasuryBps, redemptionFeeLabOwnerBps, redemptionFeeTreasuryBps);\n  }\n\n  function setCooldown(uint64 seconds_) external onlyAdmin {\n    if (seconds_ > 30 days) revert InvalidParameter();\n    cooldownSeconds = seconds_;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  function setEpochExitCapBps(uint16 bps) external onlyAdmin {\n    if (bps > MAX_EXIT_CAP_BPS) revert InvalidParameter();\n    epochExitCapBps = bps;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  /// @notice Emergency pause of vault operations\n  /// @dev Only callable by admin\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause vault operations\n  /// @dev Only callable by admin\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  function _maybeEmitLevelChange() internal {\n    emit LevelChanged(getLevel(), totalAssets);\n  }\n\n  function _rollEpochIfNeeded() internal {\n    if (_currentTime() >= epochStart + 86400) {\n      epochStart = uint64(_currentTime());\n      epochExitedAssets = 0;\n      emit EpochRolled(epochStart);\n    }\n  }\n\n  function _checkAndAccrueExitCap(uint256 assets) internal {\n    uint256 cap = (totalAssets * epochExitCapBps) / 10_000;\n    require(epochExitedAssets + assets <= cap, \"epoch cap\");\n    epochExitedAssets += assets;\n  }\n\n  // ============================================\n  // TESTING FUNCTIONS (TESTNET ONLY)\n  // ============================================\n  \n  /// @notice Enable/disable test mode\n  /// @dev Only admin can call. Test mode allows level override\n  function setTestMode(bool enabled) external onlyAdmin {\n    testMode = enabled;\n  }\n  \n  /// @notice Set override level (only works in test mode)\n  /// @dev Allows testing app slots without full TVL\n  function setOverrideLevel(uint8 level) external onlyAdmin {\n    require(level <= 3, \"invalid level\");\n    overrideLevel = level;\n  }\n  \n  /// @notice Set time offset for testing\n  /// @dev Allows fast-forwarding time to test cooldowns\n  function setTestTimeOffset(uint256 offset) external onlyAdmin {\n    require(offset <= 365 days, \"offset too large\");\n    testTimeOffset = offset;\n  }\n  \n  /// @notice Reset epoch (allows more exits immediately)\n  /// @dev Useful for testing exit caps\n  function resetEpoch() external onlyAdmin {\n    epochStart = uint64(_currentTime());\n    epochExitedAssets = 0;\n    emit EpochRolled(epochStart);\n  }\n  \n  /// @notice Force complete a redemption request (bypass cooldown)\n  /// @dev TESTNET ONLY - Allows immediate claim for testing\n  function forceCompleteRedemption(uint256 requestId) external onlyAdmin {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"already claimed\");\n    r.unlockTime = uint64(_currentTime());\n  }\n  \n  /// @notice Get current time with offset applied\n  /// @dev Used internally for all time checks\n  function _currentTime() internal view returns (uint256) {\n    return block.timestamp + testTimeOffset;\n  }\n}"},"contracts/tokens/ERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC20Base\n/// @notice Gas-optimized ERC20 base implementation with assembly optimizations\n/// @dev Uses assembly for critical path operations to minimize gas costs\nabstract contract ERC20Base {\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n  uint256 private _totalSupply;\n\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) { return _name; }\n  function symbol() public view returns (string memory) { return _symbol; }\n  function decimals() public view returns (uint8) { return _decimals; }\n  function totalSupply() public view returns (uint256) { return _totalSupply; }\n  function balanceOf(address account) public view returns (uint256) { return _balances[account]; }\n  function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; }\n\n  function transfer(address to, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[from][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked { _approve(from, msg.sender, currentAllowance - amount); }\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /// @notice Internal transfer function with assembly optimization\n  /// @dev Uses assembly for gas-efficient balance updates\n  /// @param from Address to transfer from\n  /// @param to Address to transfer to\n  /// @param amount Amount to transfer\n  function _transfer(address from, address to, uint256 amount) internal {\n    require(from != address(0) && to != address(0), \"ERC20: zero address\");\n    \n    // Assembly optimized balance operations\n    assembly {\n      // Load balance storage slot for 'from'\n      mstore(0x00, from)\n      mstore(0x20, _balances.slot)\n      let fromBalanceSlot := keccak256(0x00, 0x40)\n      let fromBalance := sload(fromBalanceSlot)\n      \n      // Check sufficient balance\n      if lt(fromBalance, amount) {\n        mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000) // Error selector\n        mstore(0x04, 0x20)\n        mstore(0x24, 27)\n        mstore(0x44, \"ERC20: transfer exceeds balance\")\n        revert(0x00, 0x64)\n      }\n      \n      // Update from balance\n      sstore(fromBalanceSlot, sub(fromBalance, amount))\n      \n      // Load and update balance storage slot for 'to'\n      mstore(0x00, to)\n      let toBalanceSlot := keccak256(0x00, 0x40)\n      let toBalance := sload(toBalanceSlot)\n      sstore(toBalanceSlot, add(toBalance, amount))\n    }\n    \n    emit Transfer(from, to, amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0) && spender != address(0), \"ERC20: zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: mint to zero\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal {\n    uint256 fromBal = _balances[from];\n    require(fromBal >= amount, \"ERC20: burn exceeds balance\");\n    unchecked { _balances[from] = fromBal - amount; }\n    _totalSupply -= amount;\n    emit Transfer(from, address(0), amount);\n  }\n\n  /// @notice Batch transfer tokens to multiple recipients (gas optimized)\n  /// @dev Useful for airdrops and mass distributions\n  /// @param recipients Array of recipient addresses\n  /// @param amounts Array of amounts to transfer\n  /// @return success True if all transfers succeeded\n  function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) public returns (bool success) {\n    uint256 length = recipients.length;\n    require(length == amounts.length, \"ERC20: length mismatch\");\n    \n    for (uint256 i; i < length; ) {\n      _transfer(msg.sender, recipients[i], amounts[i]);\n      unchecked { ++i; }\n    }\n    \n    return true;\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}