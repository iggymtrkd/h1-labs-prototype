{"language":"Solidity","sources":{"contracts/facets/contracts/facets/TestingFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\nimport { LibDiamond } from \"../diamond-standard/libraries/LibDiamond.sol\";\nimport { LabVault } from \"../vaults/LabVault.sol\";\nimport { LABSToken } from \"../tokens/LABSToken.sol\";\n\n/// @title TestingFacet\n/// @notice Admin testing utilities for accelerating testnet development\n/// @dev ⚠️ TESTNET ONLY - Contains privileged functions for testing financial flows\n/// @custom:security Should NOT be deployed to mainnet\ncontract TestingFacet {\n  event TestingParameterUpdated(string indexed parameter, uint256 value, address indexed target);\n  event LABSMinted(address indexed to, uint256 amount);\n  event VaultTimeOffsetSet(address indexed vault, uint256 offset);\n  event VaultLevelOverridden(address indexed vault, uint8 level);\n  event VaultTestModeChanged(address indexed vault, bool enabled);\n  event EpochForceReset(address indexed vault, uint64 newEpochStart);\n  event DefaultsInitialized(uint64 cooldown, uint16 exitCapBps, uint16 curveFeeBps, uint16 curvePolBps);\n  event ProtocolConfigurationUpdated(string indexed parameter, uint256 value);\n  \n  error Unauthorized();\n  error InvalidAddress();\n  error InvalidParameter();\n  \n  /// @notice Ensures only diamond owner can call testing functions\n  modifier onlyOwner() {\n    LibDiamond.enforceIsContractOwner();\n    _;\n  }\n  \n  // ============================================\n  // INITIALIZATION & CONFIGURATION\n  // ============================================\n  \n  /// @notice Initialize protocol with default values (can only be called once)\n  /// @dev Sets default cooldown, exit cap, curve fees, and POL allocation\n  /// @param treasury Protocol treasury address\n  function initializeDefaults(address treasury) external onlyOwner {\n    if (treasury == address(0)) revert InvalidAddress();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    require(!hs.defaultsInitialized, \"Defaults already initialized\");\n    \n    hs.defaultCooldown = LibH1Storage.DEFAULT_COOLDOWN;\n    hs.defaultExitCapBps = LibH1Storage.DEFAULT_EXIT_CAP_BPS;\n    hs.curveFeeBps = LibH1Storage.DEFAULT_CURVE_FEE_BPS;\n    hs.curvePolBps = LibH1Storage.DEFAULT_CURVE_POL_BPS;\n    hs.protocolTreasury = treasury;\n    hs.defaultsInitialized = true;\n    \n    emit DefaultsInitialized(\n      LibH1Storage.DEFAULT_COOLDOWN,\n      LibH1Storage.DEFAULT_EXIT_CAP_BPS,\n      LibH1Storage.DEFAULT_CURVE_FEE_BPS,\n      LibH1Storage.DEFAULT_CURVE_POL_BPS\n    );\n  }\n  \n  // ============================================\n  // LABS TOKEN TESTING FUNCTIONS\n  // ============================================\n  \n  /// @notice Mint LABS tokens to any address (TESTNET ONLY)\n  /// @dev Allows admin to distribute LABS for testing without needing faucet\n  /// @param to Recipient address\n  /// @param amount Amount of LABS to mint (18 decimals)\n  function mintLABS(address to, uint256 amount) external onlyOwner {\n    if (to == address(0)) revert InvalidAddress();\n    if (amount == 0) revert InvalidParameter();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    require(hs.labsToken != address(0), \"LABS token not set\");\n    \n    LABSToken(hs.labsToken).mint(to, amount);\n    emit LABSMinted(to, amount);\n  }\n  \n  /// @notice Batch mint LABS to multiple addresses\n  /// @dev Useful for airdropping to test users\n  /// @param recipients Array of recipient addresses\n  /// @param amounts Array of amounts (must match recipients length)\n  function batchMintLABS(address[] calldata recipients, uint256[] calldata amounts) external onlyOwner {\n    require(recipients.length == amounts.length, \"length mismatch\");\n    require(recipients.length <= 100, \"too many recipients\");\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    require(hs.labsToken != address(0), \"LABS token not set\");\n    \n    for (uint256 i = 0; i < recipients.length; i++) {\n      if (recipients[i] == address(0)) revert InvalidAddress();\n      if (amounts[i] == 0) continue;\n      LABSToken(hs.labsToken).mint(recipients[i], amounts[i]);\n      emit LABSMinted(recipients[i], amounts[i]);\n    }\n  }\n  \n  // ============================================\n  // VAULT TESTING FUNCTIONS\n  // ============================================\n  \n  /// @notice Override vault cooldown period\n  /// @dev Allows setting cooldown to minutes instead of days for testing\n  /// @param vault Address of LabVault\n  /// @param seconds_ New cooldown in seconds (can be very short for testing)\n  function setVaultCooldown(address vault, uint64 seconds_) external onlyOwner {\n    if (vault == address(0)) revert InvalidAddress();\n    if (seconds_ > 30 days) revert InvalidParameter();\n    \n    LabVault(vault).setCooldown(seconds_);\n    emit TestingParameterUpdated(\"cooldown\", seconds_, vault);\n  }\n  \n  /// @notice Override vault exit cap\n  /// @dev Allows testing exit limits by modifying cap percentage\n  /// @param vault Address of LabVault\n  /// @param bps Exit cap in basis points (10000 = 100%)\n  function setVaultExitCap(address vault, uint16 bps) external onlyOwner {\n    if (vault == address(0)) revert InvalidAddress();\n    if (bps > 10000) revert InvalidParameter();\n    \n    LabVault(vault).setEpochExitCapBps(bps);\n    emit TestingParameterUpdated(\"exitCap\", bps, vault);\n  }\n  \n  /// @notice Set time offset for vault (fast-forward time)\n  /// @dev Allows testing cooldown expiry without waiting days\n  /// @param vault Address of LabVault\n  /// @param offset Seconds to add to block.timestamp\n  function setVaultTimeOffset(address vault, uint256 offset) external onlyOwner {\n    if (vault == address(0)) revert InvalidAddress();\n    // Allow up to 365 days offset\n    if (offset > 365 days) revert InvalidParameter();\n    \n    LabVault(vault).setTestTimeOffset(offset);\n    emit VaultTimeOffsetSet(vault, offset);\n  }\n  \n  /// @notice Enable/disable test mode for vault\n  /// @dev Test mode allows level override and other testing features\n  /// @param vault Address of LabVault\n  /// @param enabled True to enable test mode\n  function setVaultTestMode(address vault, bool enabled) external onlyOwner {\n    if (vault == address(0)) revert InvalidAddress();\n    \n    LabVault(vault).setTestMode(enabled);\n    emit VaultTestModeChanged(vault, enabled);\n  }\n  \n  /// @notice Override vault level (bypass TVL requirements)\n  /// @dev Allows testing app slots without depositing full amounts\n  /// @param vault Address of LabVault\n  /// @param level Level to set (0-3)\n  function overrideVaultLevel(address vault, uint8 level) external onlyOwner {\n    if (vault == address(0)) revert InvalidAddress();\n    if (level > 3) revert InvalidParameter();\n    \n    LabVault(vault).setOverrideLevel(level);\n    emit VaultLevelOverridden(vault, level);\n  }\n  \n  /// @notice Reset vault epoch (allows more exits immediately)\n  /// @dev Useful for testing exit cap limits without waiting 24 hours\n  /// @param vault Address of LabVault\n  function resetVaultEpoch(address vault) external onlyOwner {\n    if (vault == address(0)) revert InvalidAddress();\n    \n    LabVault(vault).resetEpoch();\n    emit EpochForceReset(vault, uint64(block.timestamp));\n  }\n  \n  /// @notice Force complete a redemption request (bypass cooldown)\n  /// @dev Allows testing claim flow without waiting for cooldown\n  /// @param vault Address of LabVault\n  /// @param requestId Redemption request ID\n  function forceCompleteRedemption(address vault, uint256 requestId) external onlyOwner {\n    if (vault == address(0)) revert InvalidAddress();\n    \n    LabVault(vault).forceCompleteRedemption(requestId);\n    emit TestingParameterUpdated(\"forceComplete\", requestId, vault);\n  }\n  \n  // ============================================\n  // PROTOCOL CONFIGURATION WITH DEFAULTS\n  // ============================================\n  \n  /// @notice Override default cooldown for new vaults\n  /// @dev Affects only vaults created after this call\n  /// @param seconds_ Default cooldown in seconds\n  function setDefaultCooldown(uint64 seconds_) external onlyOwner {\n    if (seconds_ > 30 days) revert InvalidParameter();\n    LibH1Storage.h1Storage().defaultCooldown = seconds_;\n    emit ProtocolConfigurationUpdated(\"defaultCooldown\", seconds_);\n  }\n  \n  /// @notice Override default exit cap for new vaults\n  /// @dev Affects only vaults created after this call\n  /// @param bps Exit cap in basis points\n  function setDefaultExitCap(uint16 bps) external onlyOwner {\n    if (bps > 10000) revert InvalidParameter();\n    LibH1Storage.h1Storage().defaultExitCapBps = bps;\n    emit ProtocolConfigurationUpdated(\"defaultExitCap\", bps);\n  }\n  \n  /// @notice Override bonding curve fee\n  /// @dev Affects only curves created after this call\n  /// @param feeBps Fee in basis points (max 1000 = 10%)\n  function setCurveFeeBps(uint16 feeBps) external onlyOwner {\n    if (feeBps > 1000) revert InvalidParameter();\n    LibH1Storage.h1Storage().curveFeeBps = feeBps;\n    emit ProtocolConfigurationUpdated(\"curveFeeBps\", feeBps);\n  }\n  \n  /// @notice Override bonding curve POL allocation\n  /// @dev Affects only curves created after this call\n  /// @param polBps POL in basis points (max 1000 = 10%)\n  function setCurvePolBps(uint16 polBps) external onlyOwner {\n    if (polBps > 1000) revert InvalidParameter();\n    LibH1Storage.h1Storage().curvePolBps = polBps;\n    emit ProtocolConfigurationUpdated(\"curvePolBps\", polBps);\n  }\n  \n  /// @notice Override protocol treasury address\n  /// @param treasury New treasury address\n  function setProtocolTreasury(address treasury) external onlyOwner {\n    if (treasury == address(0)) revert InvalidAddress();\n    LibH1Storage.h1Storage().protocolTreasury = treasury;\n    emit ProtocolConfigurationUpdated(\"protocolTreasury\", uint256(uint160(treasury)));\n  }\n  \n  // ============================================\n  // QUERY FUNCTIONS\n  // ============================================\n  \n  /// @notice Get all default configuration values\n  /// @return defaultCooldown Default cooldown for new vaults\n  /// @return defaultExitCapBps Default exit cap for new vaults\n  /// @return curveFeeBps Default curve fee\n  /// @return curvePolBps Default curve POL allocation\n  function getDefaultConfiguration() external view returns (\n    uint64 defaultCooldown,\n    uint16 defaultExitCapBps,\n    uint16 curveFeeBps,\n    uint16 curvePolBps\n  ) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    defaultCooldown = hs.defaultCooldown;\n    defaultExitCapBps = hs.defaultExitCapBps;\n    curveFeeBps = hs.curveFeeBps;\n    curvePolBps = hs.curvePolBps;\n  }\n  \n  /// @notice Get all testing-related parameters for a vault\n  /// @param vault Address of LabVault\n  /// @return cooldown Current cooldown\n  /// @return exitCapBps Current exit cap\n  /// @return testMode Whether test mode is enabled\n  /// @return timeOffset Current time offset\n  function getVaultTestParams(address vault) external view returns (\n    uint64 cooldown,\n    uint16 exitCapBps,\n    bool testMode,\n    uint256 timeOffset\n  ) {\n    LabVault v = LabVault(vault);\n    cooldown = v.cooldownSeconds();\n    exitCapBps = v.epochExitCapBps();\n    testMode = v.testMode();\n    timeOffset = v.testTimeOffset();\n  }\n  \n  /// @notice Get all global protocol parameters\n  /// @return labsToken LABS token address\n  /// @return protocolTreasury Treasury address\n  /// @return defaultCooldown Default cooldown for new vaults\n  /// @return defaultExitCapBps Default exit cap for new vaults\n  /// @return curveFeeBps Curve fee for new curves\n  /// @return curvePolBps Curve POL for new curves\n  /// @return defaultsInitialized Whether defaults have been initialized\n  function getProtocolParams() external view returns (\n    address labsToken,\n    address protocolTreasury,\n    uint64 defaultCooldown,\n    uint16 defaultExitCapBps,\n    uint16 curveFeeBps,\n    uint16 curvePolBps,\n    bool defaultsInitialized\n  ) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    labsToken = hs.labsToken;\n    protocolTreasury = hs.protocolTreasury;\n    defaultCooldown = hs.defaultCooldown;\n    defaultExitCapBps = hs.defaultExitCapBps;\n    curveFeeBps = hs.curveFeeBps;\n    curvePolBps = hs.curvePolBps;\n    defaultsInitialized = hs.defaultsInitialized;\n  }\n\n  /// @notice Get total LABS staked by a user (protocol-level eligibility stake)\n  /// @param user Address to query\n  /// @return amount Amount of LABS staked by the user\n  function getStakedBalance(address user) external view returns (uint256 amount) {\n    amount = LibH1Storage.h1Storage().stakedBalances[user];\n  }\n}"},"contracts/facets/contracts/tokens/LABSToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC20Base } from \"./ERC20Base.sol\";\n\ncontract LABSToken is ERC20Base {\n  address private _owner;\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  modifier onlyOwner() {\n    require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  constructor(address initialOwner) ERC20Base(\"LABS\", \"LABS\", 18) {\n    _owner = initialOwner;\n  }\n\n  function owner() external view returns (address) { return _owner; }\n\n  function transferOwnership(address newOwner) external onlyOwner { \n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    address prev = _owner;\n    _owner = newOwner; \n    emit OwnershipTransferred(prev, newOwner);\n  }\n\n  function mint(address to, uint256 amount) external onlyOwner { _mint(to, amount); }\n}\n\n\n"},"contracts/facets/contracts/vaults/LabVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC20Base } from \"../tokens/ERC20Base.sol\";\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract LabVault is ERC20Base {\n  address public immutable labsToken;\n  string public labDisplayName;\n  address public admin;\n  address public labOwner;           // New: Lab owner receives 1.5% of fees\n  address public treasury;           // New: H1 treasury receives 1% of fees\n\n  uint256 public constant LEVEL1 = 100_000e18;\n  uint256 public constant LEVEL2 = 250_000e18;\n  uint256 public constant LEVEL3 = 500_000e18;\n  uint16 public constant MAX_EXIT_CAP_BPS = 10_000; // 100%\n  uint16 public constant MAX_TOTAL_FEE_BPS = 250;   // 2.5% max total fee (1.5% + 1%)\n\n  uint64 public cooldownSeconds;\n  uint16 public epochExitCapBps;\n  uint64 public epochStart;\n  \n  // Fee configuration (basis points) - Total: 2.5% (1.5% + 1%)\n  uint16 public depositFeeLabOwnerBps = 150;        // 1.5% to lab owner (default)\n  uint16 public depositFeeTreasuryBps = 100;        // 1% to treasury (default)\n  uint16 public redemptionFeeLabOwnerBps = 150;     // 1.5% to lab owner (default)\n  uint16 public redemptionFeeTreasuryBps = 100;     // 1% to treasury (default)\n\n  uint256 public totalAssets;\n  uint256 public pendingExitAssets;\n  uint256 public epochExitedAssets;\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n\n  modifier nonReentrant() {\n    require(status == NOT_ENTERED, \"reentrancy\");\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  // Optimized struct packing: 2 storage slots instead of 4\n  struct RedeemRequest {\n    address owner;      // 20 bytes\n    uint64 unlockTime;  // 8 bytes  \n    bool claimed;       // 1 byte\n    // Total: 29 bytes in slot 1 (3 bytes padding)\n    uint256 assets;     // 32 bytes in slot 2\n  }\n\n  uint256 public nextRequestId;\n  mapping(uint256 => RedeemRequest) public redeemRequests;\n\n  event Deposited(address indexed caller, address indexed receiver, uint256 assets, uint256 shares);\n  event DepositFeeCollected(address indexed caller, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemRequested(uint256 indexed requestId, address indexed owner, uint256 sharesBurned, uint256 assets, uint64 unlockTime);\n  event RedemptionFeeCollected(uint256 indexed requestId, address indexed owner, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemClaimed(uint256 indexed requestId, address indexed owner, uint256 assets);\n  event RedeemCanceled(uint256 indexed requestId, address indexed owner, uint256 assets, uint256 sharesReMinted);\n  event LevelChanged(uint8 newLevel, uint256 totalAssets);\n  event ExitCapsUpdated(uint64 cooldownSeconds, uint16 epochExitCapBps);\n  event EpochRolled(uint64 newEpochStart);\n  event RedeemFilled(uint256 indexed requestId, address indexed filler, uint256 assets, address receiver);\n  event AdminUpdated(address indexed newAdmin);\n  event LabOwnerUpdated(address indexed newLabOwner);\n  event TreasuryUpdated(address indexed newTreasury);\n  event FeesUpdated(uint16 depositLabOwnerBps, uint16 depositTreasuryBps, uint16 redemptionLabOwnerBps, uint16 redemptionTreasuryBps);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n\n  error Unauthorized();\n  error InvalidAddress();\n  error InvalidAmount();\n  error InvalidParameter();\n  error ContractPaused();\n\n  bool private _paused;\n\n  // Testing variables (TESTNET ONLY)\n  bool public testMode;\n  uint8 public overrideLevel;\n  uint256 public testTimeOffset;\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  constructor(\n    address labsToken_,\n    string memory h1Name_,\n    string memory h1Symbol_,\n    string memory labDisplayName_,\n    uint64 cooldownSeconds_,\n    uint16 epochExitCapBps_,\n    address admin_,\n    address labOwner_,\n    address treasury_\n  ) ERC20Base(h1Name_, h1Symbol_, 18) {\n    require(labsToken_ != address(0), \"labs token = 0\");\n    require(labOwner_ != address(0), \"lab owner = 0\");\n    require(treasury_ != address(0), \"treasury = 0\");\n    require(bytes(h1Name_).length > 0 && bytes(h1Name_).length <= 50, \"invalid name\");\n    require(bytes(h1Symbol_).length > 0 && bytes(h1Symbol_).length <= 10, \"invalid symbol\");\n    require(epochExitCapBps_ <= MAX_EXIT_CAP_BPS, \"exit cap > 100%\");\n    \n    labsToken = labsToken_;\n    labDisplayName = labDisplayName_;\n    cooldownSeconds = cooldownSeconds_;\n    epochExitCapBps = epochExitCapBps_;\n    admin = admin_;\n    labOwner = labOwner_;\n    treasury = treasury_;\n  }\n\n  function assetsPerShare() public view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 1e18;\n    return (totalAssets * 1e18) / supply;\n  }\n\n  function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n    uint256 rate = assetsPerShare();\n    shares = (assets * 1e18) / rate;\n  }\n\n  function previewMint(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  /// @notice Preview deposit accounting for deposit fee\n  function previewDepositWithFee(uint256 assets) public view returns (uint256 shares, uint256 labOwnerFee, uint256 treasuryFee) {\n    labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    shares = previewDeposit(netAssets);\n  }\n\n  /// @notice Preview redemption accounting for redemption fee\n  function previewRedeemWithFee(uint256 shares) public view returns (uint256 assets, uint256 labOwnerFee, uint256 treasuryFee) {\n    assets = previewRedeem(shares);\n    labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n  }\n\n  function getLevel() public view returns (uint8 level) {\n    // If in test mode and override level is set, return it\n    if (testMode && overrideLevel > 0) {\n      return overrideLevel;\n    }\n    \n    // Normal level calculation\n    uint256 a = totalAssets;\n    if (a >= LEVEL3) return 3;\n    if (a >= LEVEL2) return 2;\n    if (a >= LEVEL1) return 1;\n    return 0;\n  }\n\n  function getAppSlots() external view returns (uint8 slots) {\n    uint8 level = getLevel();\n    if (level == 3) return 3;\n    if (level == 2) return 2;\n    if (level == 1) return 1;\n    return 0;\n  }\n\n  function depositLABS(uint256 assets, address receiver) external nonReentrant whenNotPaused returns (uint256 shares) {\n    require(assets > 0, \"zero assets\");\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    \n    shares = previewDeposit(netAssets);\n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), assets), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += netAssets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, netAssets, shares);\n  }\n\n  function mintShares(uint256 shares, address receiver) external nonReentrant whenNotPaused returns (uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewMint(shares);\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 totalRequired = assets + (labOwnerFee + treasuryFee);\n    \n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), totalRequired), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += assets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, assets, shares);\n  }\n\n  function requestRedeem(uint256 shares) external nonReentrant whenNotPaused returns (uint256 requestId, uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewRedeem(shares);\n    \n    // Calculate redemption fees\n    uint256 labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n    \n    _rollEpochIfNeeded();\n    _checkAndAccrueExitCap(assets);\n    _burn(msg.sender, shares);\n    pendingExitAssets += assets;\n    uint64 unlockTime = uint64(_currentTime()) + cooldownSeconds;\n    requestId = ++nextRequestId;\n    redeemRequests[requestId] = RedeemRequest({ owner: msg.sender, assets: assets, unlockTime: unlockTime, claimed: false });\n    emit RedemptionFeeCollected(requestId, msg.sender, labOwnerFee, treasuryFee);\n    emit RedeemRequested(requestId, msg.sender, shares, assets, unlockTime);\n  }\n\n  function cancelRedeem(uint256 requestId) external nonReentrant returns (uint256 shares) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(r.owner == msg.sender, \"not owner\");\n    require(!r.claimed, \"claimed\");\n    uint256 assets = r.assets;\n    delete redeemRequests[requestId];\n    pendingExitAssets -= assets;\n    shares = previewDeposit(assets);\n    _mint(msg.sender, shares);\n    emit RedeemCanceled(requestId, msg.sender, assets, shares);\n  }\n\n  function claimRedeem(uint256 requestId) external nonReentrant {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    require(_currentTime() >= r.unlockTime, \"cooldown\");\n    pendingExitAssets -= r.assets;\n    r.claimed = true;\n    totalAssets -= r.assets;\n    \n    // Calculate and apply fees at claim time\n    uint256 labOwnerFee = (r.assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (r.assets * redemptionFeeTreasuryBps) / 10_000;\n    uint256 netAssets = r.assets - (labOwnerFee + treasuryFee);\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    require(IERC20(labsToken).transfer(r.owner, netAssets), \"transfer fail\");\n    _maybeEmitLevelChange();\n    emit RedeemClaimed(requestId, r.owner, netAssets);\n  }\n\n  function fillRedeem(uint256 requestId, address receiver) external nonReentrant returns (uint256 sharesMinted) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    _rollEpochIfNeeded();\n    uint256 assets = r.assets;\n    require(IERC20(labsToken).transferFrom(msg.sender, r.owner, assets), \"fill xfer fail\");\n    pendingExitAssets -= assets;\n    r.claimed = true;\n    sharesMinted = 0;\n    emit RedeemFilled(requestId, msg.sender, assets, receiver);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n\n  function setLabOwner(address newLabOwner) external onlyAdmin {\n    if (newLabOwner == address(0)) revert InvalidAddress();\n    labOwner = newLabOwner;\n    emit LabOwnerUpdated(newLabOwner);\n  }\n\n  function setTreasury(address newTreasury) external onlyAdmin {\n    if (newTreasury == address(0)) revert InvalidAddress();\n    treasury = newTreasury;\n    emit TreasuryUpdated(newTreasury);\n  }\n\n  /// @notice Set deposit and redemption fees (in basis points)\n  /// @dev Both fees must be <= 100 bps (1%)\n  function setFees(uint16 depositLabOwnerBps_, uint16 depositTreasuryBps_, uint16 redemptionLabOwnerBps_, uint16 redemptionTreasuryBps_) external onlyAdmin {\n    require(depositLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"deposit lab owner fee too high\");\n    require(depositTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"deposit treasury fee too high\");\n    require(redemptionLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"redemption lab owner fee too high\");\n    require(redemptionTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"redemption treasury fee too high\");\n    depositFeeLabOwnerBps = depositLabOwnerBps_;\n    depositFeeTreasuryBps = depositTreasuryBps_;\n    redemptionFeeLabOwnerBps = redemptionLabOwnerBps_;\n    redemptionFeeTreasuryBps = redemptionTreasuryBps_;\n    emit FeesUpdated(depositFeeLabOwnerBps, depositFeeTreasuryBps, redemptionFeeLabOwnerBps, redemptionFeeTreasuryBps);\n  }\n\n  function setCooldown(uint64 seconds_) external onlyAdmin {\n    if (seconds_ > 30 days) revert InvalidParameter();\n    cooldownSeconds = seconds_;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  function setEpochExitCapBps(uint16 bps) external onlyAdmin {\n    if (bps > MAX_EXIT_CAP_BPS) revert InvalidParameter();\n    epochExitCapBps = bps;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  /// @notice Emergency pause of vault operations\n  /// @dev Only callable by admin\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause vault operations\n  /// @dev Only callable by admin\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  function _maybeEmitLevelChange() internal {\n    emit LevelChanged(getLevel(), totalAssets);\n  }\n\n  function _rollEpochIfNeeded() internal {\n    if (_currentTime() >= epochStart + 86400) {\n      epochStart = uint64(_currentTime());\n      epochExitedAssets = 0;\n      emit EpochRolled(epochStart);\n    }\n  }\n\n  function _checkAndAccrueExitCap(uint256 assets) internal {\n    uint256 cap = (totalAssets * epochExitCapBps) / 10_000;\n    require(epochExitedAssets + assets <= cap, \"epoch cap\");\n    epochExitedAssets += assets;\n  }\n\n  // ============================================\n  // TESTING FUNCTIONS (TESTNET ONLY)\n  // ============================================\n  \n  /// @notice Enable/disable test mode\n  /// @dev Only admin can call. Test mode allows level override\n  function setTestMode(bool enabled) external onlyAdmin {\n    testMode = enabled;\n  }\n  \n  /// @notice Set override level (only works in test mode)\n  /// @dev Allows testing app slots without full TVL\n  function setOverrideLevel(uint8 level) external onlyAdmin {\n    require(level <= 3, \"invalid level\");\n    overrideLevel = level;\n  }\n  \n  /// @notice Set time offset for testing\n  /// @dev Allows fast-forwarding time to test cooldowns\n  function setTestTimeOffset(uint256 offset) external onlyAdmin {\n    require(offset <= 365 days, \"offset too large\");\n    testTimeOffset = offset;\n  }\n  \n  /// @notice Reset epoch (allows more exits immediately)\n  /// @dev Useful for testing exit caps\n  function resetEpoch() external onlyAdmin {\n    epochStart = uint64(_currentTime());\n    epochExitedAssets = 0;\n    emit EpochRolled(epochStart);\n  }\n  \n  /// @notice Force complete a redemption request (bypass cooldown)\n  /// @dev TESTNET ONLY - Allows immediate claim for testing\n  function forceCompleteRedemption(uint256 requestId) external onlyAdmin {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"already claimed\");\n    r.unlockTime = uint64(_currentTime());\n  }\n  \n  /// @notice Get current time with offset applied\n  /// @dev Used internally for all time checks\n  function _currentTime() internal view returns (uint256) {\n    return block.timestamp + testTimeOffset;\n  }\n}"},"contracts/facets/contracts/diamond-standard/libraries/LibDiamond.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\nlibrary LibDiamond {\n  bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint96 selectorPosition;\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint256 facetAddressPosition;\n  }\n\n  struct DiamondStorage {\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    address[] facetAddresses;\n    address contractOwner;\n    mapping(address => bool) approvedInitializers; // Whitelist for delegatecall\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  event InitializerApproved(address indexed initializer);\n  event InitializerRevoked(address indexed initializer);\n\n  error NotContractOwner(address sender, address owner);\n  error InitZeroAddress();\n  error InitCallFailed(bytes data);\n  error InitializerNotApproved(address initializer);\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  function setContractOwner(address _newOwner) internal {\n    DiamondStorage storage ds = diamondStorage();\n    address previousOwner = ds.contractOwner;\n    ds.contractOwner = _newOwner;\n    emit OwnershipTransferred(previousOwner, _newOwner);\n  }\n\n  function enforceIsContractOwner() internal view {\n    DiamondStorage storage ds = diamondStorage();\n    if (msg.sender != ds.contractOwner) {\n      revert NotContractOwner(msg.sender, ds.contractOwner);\n    }\n  }\n\n  function diamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    uint256 length = _diamondCut.length; // Cache array length for gas optimization\n    for (uint256 facetIndex; facetIndex < length; ) {\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n      if (action == IDiamondCut.FacetCutAction.Add) {\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      }\n      unchecked { ++facetIndex; } // Safe: facetIndex < length\n    }\n    emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);\n    initializeDiamondCut(_init, _calldata);\n  }\n\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to add\");\n    DiamondStorage storage ds = diamondStorage();\n    uint256 selectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length;\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress == address(0), \"LibDiamond: Selector already exists\");\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      unchecked { \n        ++selectorPosition;\n        ++selectorIndex;\n      } // Safe: bounded by array length\n    }\n  }\n\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to replace\");\n    DiamondStorage storage ds = diamondStorage();\n    uint256 selectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length;\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress != _facetAddress, \"LibDiamond: Replace facet is same\");\n      removeFunction(ds, oldFacetAddress, selector);\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      unchecked { \n        ++selectorPosition;\n        ++selectorIndex;\n      } // Safe: bounded by array length\n    }\n  }\n\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_facetAddress == address(0), \"LibDiamond: Remove facetAddress must be address(0)\");\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to remove\");\n    DiamondStorage storage ds = diamondStorage();\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      removeFunction(ds, oldFacetAddress, selector);\n      unchecked { ++selectorIndex; } // Safe: bounded by array length\n    }\n  }\n\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n    require(_facetAddress != address(0), \"LibDiamond: Add facet address(0)\");\n    require(_facetAddress.code.length > 0, \"LibDiamond: Add facet has no code\");\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n    ds.facetAddresses.push(_facetAddress);\n  }\n\n  function addFunction(\n    DiamondStorage storage ds,\n    bytes4 _selector,\n    uint256 _selectorPosition,\n    address _facetAddress\n  ) internal {\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    ds.selectorToFacetAndPosition[_selector].selectorPosition = uint96(_selectorPosition);\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n  }\n\n  function removeFunction(\n    DiamondStorage storage ds,\n    address _facetAddress,\n    bytes4 _selector\n  ) internal {\n    require(_facetAddress != address(0), \"LibDiamond: Remove facet address(0)\");\n    require(_facetAddress != address(this), \"LibDiamond: Can't remove immutable functions\");\n\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].selectorPosition;\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\n    if (selectorPosition != lastSelectorPosition) {\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n      ds.selectorToFacetAndPosition[lastSelector].selectorPosition = uint96(selectorPosition);\n    }\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n    delete ds.selectorToFacetAndPosition[_selector];\n\n    if (ds.facetFunctionSelectors[_facetAddress].functionSelectors.length == 0) {\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n      if (facetAddressPosition != lastFacetAddressPosition) {\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n      }\n      ds.facetAddresses.pop();\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n    }\n  }\n\n  /// @notice Approves an initializer contract for delegatecall\n  /// @dev Only callable by contract owner\n  /// @param initializer Address of initializer contract to approve\n  function approveInitializer(address initializer) internal {\n    DiamondStorage storage ds = diamondStorage();\n    ds.approvedInitializers[initializer] = true;\n    emit InitializerApproved(initializer);\n  }\n\n  /// @notice Revokes an initializer contract\n  /// @dev Only callable by contract owner\n  /// @param initializer Address of initializer contract to revoke\n  function revokeInitializer(address initializer) internal {\n    DiamondStorage storage ds = diamondStorage();\n    ds.approvedInitializers[initializer] = false;\n    emit InitializerRevoked(initializer);\n  }\n\n  /// @notice Checks if an initializer is approved\n  /// @param initializer Address to check\n  /// @return True if approved, false otherwise\n  function isInitializerApproved(address initializer) internal view returns (bool) {\n    DiamondStorage storage ds = diamondStorage();\n    return ds.approvedInitializers[initializer];\n  }\n\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n    if (_init == address(0)) {\n      if (_calldata.length > 0) revert InitZeroAddress();\n      return;\n    }\n    \n    // Verify initializer is approved for security\n    DiamondStorage storage ds = diamondStorage();\n    if (!ds.approvedInitializers[_init]) {\n      revert InitializerNotApproved(_init);\n    }\n    \n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\n    if (!success) revert InitCallFailed(error);\n  }\n}\n\n\n\n"},"contracts/facets/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  // ============================================\n  // DEFAULT CONFIGURATION CONSTANTS\n  // ============================================\n  uint64 internal constant DEFAULT_COOLDOWN = 1 days;\n  uint16 internal constant DEFAULT_EXIT_CAP_BPS = 2000; // 20%\n  uint16 internal constant DEFAULT_CURVE_FEE_BPS = 500; // 5%\n  uint16 internal constant DEFAULT_CURVE_POL_BPS = 500; // 5%\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n    uint8 level;            // Level 1-3 based on staked amount (0 = no level)\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n    bool defaultsInitialized;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}"},"contracts/facets/contracts/tokens/ERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC20Base\n/// @notice Gas-optimized ERC20 base implementation with assembly optimizations\n/// @dev Uses assembly for critical path operations to minimize gas costs\nabstract contract ERC20Base {\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n  uint256 private _totalSupply;\n\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) { return _name; }\n  function symbol() public view returns (string memory) { return _symbol; }\n  function decimals() public view returns (uint8) { return _decimals; }\n  function totalSupply() public view returns (uint256) { return _totalSupply; }\n  function balanceOf(address account) public view returns (uint256) { return _balances[account]; }\n  function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; }\n\n  function transfer(address to, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[from][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked { _approve(from, msg.sender, currentAllowance - amount); }\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /// @notice Internal transfer function with assembly optimization\n  /// @dev Uses assembly for gas-efficient balance updates\n  /// @param from Address to transfer from\n  /// @param to Address to transfer to\n  /// @param amount Amount to transfer\n  function _transfer(address from, address to, uint256 amount) internal {\n    require(from != address(0) && to != address(0), \"ERC20: zero address\");\n    \n    // Assembly optimized balance operations\n    assembly {\n      // Load balance storage slot for 'from'\n      mstore(0x00, from)\n      mstore(0x20, _balances.slot)\n      let fromBalanceSlot := keccak256(0x00, 0x40)\n      let fromBalance := sload(fromBalanceSlot)\n      \n      // Check sufficient balance\n      if lt(fromBalance, amount) {\n        mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000) // Error selector\n        mstore(0x04, 0x20)\n        mstore(0x24, 27)\n        mstore(0x44, \"ERC20: transfer exceeds balance\")\n        revert(0x00, 0x64)\n      }\n      \n      // Update from balance\n      sstore(fromBalanceSlot, sub(fromBalance, amount))\n      \n      // Load and update balance storage slot for 'to'\n      mstore(0x00, to)\n      let toBalanceSlot := keccak256(0x00, 0x40)\n      let toBalance := sload(toBalanceSlot)\n      sstore(toBalanceSlot, add(toBalance, amount))\n    }\n    \n    emit Transfer(from, to, amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0) && spender != address(0), \"ERC20: zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: mint to zero\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal {\n    uint256 fromBal = _balances[from];\n    require(fromBal >= amount, \"ERC20: burn exceeds balance\");\n    unchecked { _balances[from] = fromBal - amount; }\n    _totalSupply -= amount;\n    emit Transfer(from, address(0), amount);\n  }\n\n  /// @notice Batch transfer tokens to multiple recipients (gas optimized)\n  /// @dev Useful for airdrops and mass distributions\n  /// @param recipients Array of recipient addresses\n  /// @param amounts Array of amounts to transfer\n  /// @return success True if all transfers succeeded\n  function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) public returns (bool success) {\n    uint256 length = recipients.length;\n    require(length == amounts.length, \"ERC20: length mismatch\");\n    \n    for (uint256 i; i < length; ) {\n      _transfer(msg.sender, recipients[i], amounts[i]);\n      unchecked { ++i; }\n    }\n    \n    return true;\n  }\n}\n\n\n"},"contracts/facets/contracts/diamond-standard/interfaces/IERC173.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC-173: Ownership Standard\ninterface IERC173 {\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function owner() external view returns (address owner_);\n\n  function transferOwnership(address _newOwner) external;\n}\n\n\n\n"},"contracts/facets/contracts/diamond-standard/interfaces/IDiamondCut.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDiamondCut {\n  enum FacetCutAction { Add, Replace, Remove }\n\n  struct FacetCut {\n    address facetAddress;\n    FacetCutAction action;\n    bytes4[] functionSelectors;\n  }\n\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  function diamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external;\n}\n\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}