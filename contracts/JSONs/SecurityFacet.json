{"language":"Solidity","sources":{"contracts/contracts/diamond-standard/facets/SecurityFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n/// @title SecurityFacet\n/// @notice Security management functions for the diamond\n/// @dev Provides initializer whitelist management and security controls\ncontract SecurityFacet {\n  event InitializerApproved(address indexed initializer);\n  event InitializerRevoked(address indexed initializer);\n\n  /// @notice Approves an initializer contract for delegatecall operations\n  /// @dev Only callable by diamond owner\n  /// @param initializer Address of initializer contract to approve\n  function approveInitializer(address initializer) external {\n    LibDiamond.enforceIsContractOwner();\n    require(initializer != address(0), \"SecurityFacet: zero address\");\n    require(initializer.code.length > 0, \"SecurityFacet: not a contract\");\n    LibDiamond.approveInitializer(initializer);\n  }\n\n  /// @notice Revokes an initializer contract\n  /// @dev Only callable by diamond owner\n  /// @param initializer Address of initializer contract to revoke\n  function revokeInitializer(address initializer) external {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.revokeInitializer(initializer);\n  }\n\n  /// @notice Checks if an initializer is approved\n  /// @param initializer Address to check\n  /// @return True if approved, false otherwise\n  function isInitializerApproved(address initializer) external view returns (bool) {\n    return LibDiamond.isInitializerApproved(initializer);\n  }\n}\n\n"},"contracts/contracts/diamond-standard/libraries/LibDiamond.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\nlibrary LibDiamond {\n  bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint96 selectorPosition;\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint256 facetAddressPosition;\n  }\n\n  struct DiamondStorage {\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    address[] facetAddresses;\n    address contractOwner;\n    mapping(address => bool) approvedInitializers; // Whitelist for delegatecall\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  event InitializerApproved(address indexed initializer);\n  event InitializerRevoked(address indexed initializer);\n\n  error NotContractOwner(address sender, address owner);\n  error InitZeroAddress();\n  error InitCallFailed(bytes data);\n  error InitializerNotApproved(address initializer);\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  function setContractOwner(address _newOwner) internal {\n    DiamondStorage storage ds = diamondStorage();\n    address previousOwner = ds.contractOwner;\n    ds.contractOwner = _newOwner;\n    emit OwnershipTransferred(previousOwner, _newOwner);\n  }\n\n  function enforceIsContractOwner() internal view {\n    DiamondStorage storage ds = diamondStorage();\n    if (msg.sender != ds.contractOwner) {\n      revert NotContractOwner(msg.sender, ds.contractOwner);\n    }\n  }\n\n  function diamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    uint256 length = _diamondCut.length; // Cache array length for gas optimization\n    for (uint256 facetIndex; facetIndex < length; ) {\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n      if (action == IDiamondCut.FacetCutAction.Add) {\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      }\n      unchecked { ++facetIndex; } // Safe: facetIndex < length\n    }\n    emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);\n    initializeDiamondCut(_init, _calldata);\n  }\n\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to add\");\n    DiamondStorage storage ds = diamondStorage();\n    uint256 selectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length;\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress == address(0), \"LibDiamond: Selector already exists\");\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      unchecked { \n        ++selectorPosition;\n        ++selectorIndex;\n      } // Safe: bounded by array length\n    }\n  }\n\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to replace\");\n    DiamondStorage storage ds = diamondStorage();\n    uint256 selectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length;\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress != _facetAddress, \"LibDiamond: Replace facet is same\");\n      removeFunction(ds, oldFacetAddress, selector);\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      unchecked { \n        ++selectorPosition;\n        ++selectorIndex;\n      } // Safe: bounded by array length\n    }\n  }\n\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_facetAddress == address(0), \"LibDiamond: Remove facetAddress must be address(0)\");\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to remove\");\n    DiamondStorage storage ds = diamondStorage();\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      removeFunction(ds, oldFacetAddress, selector);\n      unchecked { ++selectorIndex; } // Safe: bounded by array length\n    }\n  }\n\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n    require(_facetAddress != address(0), \"LibDiamond: Add facet address(0)\");\n    require(_facetAddress.code.length > 0, \"LibDiamond: Add facet has no code\");\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n    ds.facetAddresses.push(_facetAddress);\n  }\n\n  function addFunction(\n    DiamondStorage storage ds,\n    bytes4 _selector,\n    uint256 _selectorPosition,\n    address _facetAddress\n  ) internal {\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    ds.selectorToFacetAndPosition[_selector].selectorPosition = uint96(_selectorPosition);\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n  }\n\n  function removeFunction(\n    DiamondStorage storage ds,\n    address _facetAddress,\n    bytes4 _selector\n  ) internal {\n    require(_facetAddress != address(0), \"LibDiamond: Remove facet address(0)\");\n    require(_facetAddress != address(this), \"LibDiamond: Can't remove immutable functions\");\n\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].selectorPosition;\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\n    if (selectorPosition != lastSelectorPosition) {\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n      ds.selectorToFacetAndPosition[lastSelector].selectorPosition = uint96(selectorPosition);\n    }\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n    delete ds.selectorToFacetAndPosition[_selector];\n\n    if (ds.facetFunctionSelectors[_facetAddress].functionSelectors.length == 0) {\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n      if (facetAddressPosition != lastFacetAddressPosition) {\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n      }\n      ds.facetAddresses.pop();\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n    }\n  }\n\n  /// @notice Approves an initializer contract for delegatecall\n  /// @dev Only callable by contract owner\n  /// @param initializer Address of initializer contract to approve\n  function approveInitializer(address initializer) internal {\n    DiamondStorage storage ds = diamondStorage();\n    ds.approvedInitializers[initializer] = true;\n    emit InitializerApproved(initializer);\n  }\n\n  /// @notice Revokes an initializer contract\n  /// @dev Only callable by contract owner\n  /// @param initializer Address of initializer contract to revoke\n  function revokeInitializer(address initializer) internal {\n    DiamondStorage storage ds = diamondStorage();\n    ds.approvedInitializers[initializer] = false;\n    emit InitializerRevoked(initializer);\n  }\n\n  /// @notice Checks if an initializer is approved\n  /// @param initializer Address to check\n  /// @return True if approved, false otherwise\n  function isInitializerApproved(address initializer) internal view returns (bool) {\n    DiamondStorage storage ds = diamondStorage();\n    return ds.approvedInitializers[initializer];\n  }\n\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n    if (_init == address(0)) {\n      if (_calldata.length > 0) revert InitZeroAddress();\n      return;\n    }\n    \n    // Verify initializer is approved for security\n    DiamondStorage storage ds = diamondStorage();\n    if (!ds.approvedInitializers[_init]) {\n      revert InitializerNotApproved(_init);\n    }\n    \n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\n    if (!success) revert InitCallFailed(error);\n  }\n}\n\n\n\n"},"contracts/contracts/diamond-standard/interfaces/IERC173.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC-173: Ownership Standard\ninterface IERC173 {\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function owner() external view returns (address owner_);\n\n  function transferOwnership(address _newOwner) external;\n}\n\n\n\n"},"contracts/contracts/diamond-standard/interfaces/IDiamondCut.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDiamondCut {\n  enum FacetCutAction { Add, Replace, Remove }\n\n  struct FacetCut {\n    address facetAddress;\n    FacetCutAction action;\n    bytes4[] functionSelectors;\n  }\n\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  function diamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external;\n}\n\n\n\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}