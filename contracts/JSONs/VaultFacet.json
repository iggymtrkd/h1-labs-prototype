{"language":"Solidity","sources":{"contracts/contracts/facets/VaultFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\nimport { LabVault } from \"../vaults/LabVault.sol\";\n\ncontract VaultFacet {\n  event VaultDeployed(uint256 indexed labId, address vault);\n\n  error Unauthorized();\n  error InvalidLabId();\n  error VaultAlreadyExists();\n  error InvalidString();\n  error LabsTokenNotSet();\n\n  function deployVault(uint256 labId, string calldata h1Name, string calldata h1Symbol, string calldata labDisplayName) external returns (address vault) {\n    // Input validation\n    if (bytes(h1Name).length == 0 || bytes(h1Name).length > 50) revert InvalidString();\n    if (bytes(h1Symbol).length == 0 || bytes(h1Symbol).length > 10) revert InvalidString();\n    if (bytes(labDisplayName).length == 0 || bytes(labDisplayName).length > 100) revert InvalidString();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    if (hs.labs[labId].owner == address(0)) revert InvalidLabId();\n    if (hs.labs[labId].owner != msg.sender) revert Unauthorized();\n    if (hs.labIdToVault[labId] != address(0)) revert VaultAlreadyExists();\n    if (hs.labsToken == address(0)) revert LabsTokenNotSet();\n\n    vault = address(new LabVault(\n      hs.labsToken,\n      h1Name,\n      h1Symbol,\n      labDisplayName,\n      hs.defaultCooldown,\n      hs.defaultExitCapBps,\n      msg.sender\n    ));\n    \n    hs.labIdToVault[labId] = vault;\n    hs.labs[labId].h1Token = vault;\n    \n    emit VaultDeployed(labId, vault);\n  }\n\n  function getVault(uint256 labId) external view returns (address) {\n    return LibH1Storage.h1Storage().labIdToVault[labId];\n  }\n}\n\n\n"},"contracts/contracts/vaults/LabVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC20Base } from \"../tokens/ERC20Base.sol\";\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract LabVault is ERC20Base {\n  address public immutable labsToken;\n  string public labDisplayName;\n  address public admin;\n\n  uint256 public constant LEVEL1 = 100_000e18;\n  uint256 public constant LEVEL2 = 250_000e18;\n  uint256 public constant LEVEL3 = 500_000e18;\n  uint16 public constant MAX_EXIT_CAP_BPS = 10_000; // 100%\n\n  uint64 public cooldownSeconds;\n  uint16 public epochExitCapBps;\n  uint64 public epochStart;\n\n  uint256 public totalAssets;\n  uint256 public pendingExitAssets;\n  uint256 public epochExitedAssets;\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n\n  modifier nonReentrant() {\n    require(status == NOT_ENTERED, \"reentrancy\");\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  // Optimized struct packing: 2 storage slots instead of 4\n  struct RedeemRequest {\n    address owner;      // 20 bytes\n    uint64 unlockTime;  // 8 bytes  \n    bool claimed;       // 1 byte\n    // Total: 29 bytes in slot 1 (3 bytes padding)\n    uint256 assets;     // 32 bytes in slot 2\n  }\n\n  uint256 public nextRequestId;\n  mapping(uint256 => RedeemRequest) public redeemRequests;\n\n  event Deposited(address indexed caller, address indexed receiver, uint256 assets, uint256 shares);\n  event RedeemRequested(uint256 indexed requestId, address indexed owner, uint256 sharesBurned, uint256 assets, uint64 unlockTime);\n  event RedeemClaimed(uint256 indexed requestId, address indexed owner, uint256 assets);\n  event RedeemCanceled(uint256 indexed requestId, address indexed owner, uint256 assets, uint256 sharesReMinted);\n  event LevelChanged(uint8 newLevel, uint256 totalAssets);\n  event ExitCapsUpdated(uint64 cooldownSeconds, uint16 epochExitCapBps);\n  event EpochRolled(uint64 newEpochStart);\n  event RedeemFilled(uint256 indexed requestId, address indexed filler, uint256 assets, address receiver);\n  event AdminUpdated(address indexed newAdmin);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n\n  error Unauthorized();\n  error InvalidAddress();\n  error InvalidAmount();\n  error InvalidParameter();\n  error ContractPaused();\n\n  bool private _paused;\n\n  // Testing variables (TESTNET ONLY)\n  bool public testMode;\n  uint8 public overrideLevel;\n  uint256 public testTimeOffset;\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  constructor(\n    address labsToken_,\n    string memory h1Name_,\n    string memory h1Symbol_,\n    string memory labDisplayName_,\n    uint64 cooldownSeconds_,\n    uint16 epochExitCapBps_,\n    address admin_\n  ) ERC20Base(h1Name_, h1Symbol_, 18) {\n    require(labsToken_ != address(0), \"labs token = 0\");\n    require(bytes(h1Name_).length > 0 && bytes(h1Name_).length <= 50, \"invalid name\");\n    require(bytes(h1Symbol_).length > 0 && bytes(h1Symbol_).length <= 10, \"invalid symbol\");\n    require(epochExitCapBps_ <= MAX_EXIT_CAP_BPS, \"exit cap > 100%\");\n    \n    labsToken = labsToken_;\n    labDisplayName = labDisplayName_;\n    cooldownSeconds = cooldownSeconds_;\n    epochExitCapBps = epochExitCapBps_;\n    epochStart = uint64(block.timestamp); // Use real time for init\n    admin = admin_;\n  }\n\n  function assetsPerShare() public view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 1e18;\n    return (totalAssets * 1e18) / supply;\n  }\n\n  function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n    uint256 rate = assetsPerShare();\n    shares = (assets * 1e18) / rate;\n  }\n\n  function previewMint(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  function getLevel() public view returns (uint8 level) {\n    // If in test mode and override level is set, return it\n    if (testMode && overrideLevel > 0) {\n      return overrideLevel;\n    }\n    \n    // Normal level calculation\n    uint256 a = totalAssets;\n    if (a >= LEVEL3) return 3;\n    if (a >= LEVEL2) return 2;\n    if (a >= LEVEL1) return 1;\n    return 0;\n  }\n\n  function getAppSlots() external view returns (uint8 slots) {\n    uint8 level = getLevel();\n    if (level == 3) return 3;\n    if (level == 2) return 2;\n    if (level == 1) return 1;\n    return 0;\n  }\n\n  function depositLABS(uint256 assets, address receiver) external nonReentrant whenNotPaused returns (uint256 shares) {\n    require(assets > 0, \"zero assets\");\n    shares = previewDeposit(assets);\n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), assets), \"transferFrom fail\");\n    totalAssets += assets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit Deposited(msg.sender, receiver, assets, shares);\n  }\n\n  function mintShares(uint256 shares, address receiver) external nonReentrant whenNotPaused returns (uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewMint(shares);\n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), assets), \"transferFrom fail\");\n    totalAssets += assets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit Deposited(msg.sender, receiver, assets, shares);\n  }\n\n  function requestRedeem(uint256 shares) external nonReentrant whenNotPaused returns (uint256 requestId, uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewRedeem(shares);\n    _rollEpochIfNeeded();\n    _checkAndAccrueExitCap(assets);\n    _burn(msg.sender, shares);\n    pendingExitAssets += assets;\n    uint64 unlockTime = uint64(_currentTime()) + cooldownSeconds;\n    requestId = ++nextRequestId;\n    redeemRequests[requestId] = RedeemRequest({ owner: msg.sender, assets: assets, unlockTime: unlockTime, claimed: false });\n    emit RedeemRequested(requestId, msg.sender, shares, assets, unlockTime);\n  }\n\n  function cancelRedeem(uint256 requestId) external nonReentrant returns (uint256 shares) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(r.owner == msg.sender, \"not owner\");\n    require(!r.claimed, \"claimed\");\n    uint256 assets = r.assets;\n    delete redeemRequests[requestId];\n    pendingExitAssets -= assets;\n    shares = previewDeposit(assets);\n    _mint(msg.sender, shares);\n    emit RedeemCanceled(requestId, msg.sender, assets, shares);\n  }\n\n  function claimRedeem(uint256 requestId) external nonReentrant {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    require(_currentTime() >= r.unlockTime, \"cooldown\");\n    pendingExitAssets -= r.assets;\n    r.claimed = true;\n    totalAssets -= r.assets;\n    require(IERC20(labsToken).transfer(r.owner, r.assets), \"transfer fail\");\n    _maybeEmitLevelChange();\n    emit RedeemClaimed(requestId, r.owner, r.assets);\n  }\n\n  function fillRedeem(uint256 requestId, address receiver) external nonReentrant returns (uint256 sharesMinted) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    _rollEpochIfNeeded();\n    uint256 assets = r.assets;\n    require(IERC20(labsToken).transferFrom(msg.sender, r.owner, assets), \"fill xfer fail\");\n    pendingExitAssets -= assets;\n    r.claimed = true;\n    sharesMinted = 0;\n    emit RedeemFilled(requestId, msg.sender, assets, receiver);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n\n  function setCooldown(uint64 seconds_) external onlyAdmin {\n    if (seconds_ > 30 days) revert InvalidParameter();\n    cooldownSeconds = seconds_;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  function setEpochExitCapBps(uint16 bps) external onlyAdmin {\n    if (bps > MAX_EXIT_CAP_BPS) revert InvalidParameter();\n    epochExitCapBps = bps;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  /// @notice Emergency pause of vault operations\n  /// @dev Only callable by admin\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause vault operations\n  /// @dev Only callable by admin\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  function _maybeEmitLevelChange() internal {\n    emit LevelChanged(getLevel(), totalAssets);\n  }\n\n  function _rollEpochIfNeeded() internal {\n    if (_currentTime() >= epochStart + 86400) {\n      epochStart = uint64(_currentTime());\n      epochExitedAssets = 0;\n      emit EpochRolled(epochStart);\n    }\n  }\n\n  function _checkAndAccrueExitCap(uint256 assets) internal {\n    uint256 cap = (totalAssets * epochExitCapBps) / 10_000;\n    require(epochExitedAssets + assets <= cap, \"epoch cap\");\n    epochExitedAssets += assets;\n  }\n\n  // ============================================\n  // TESTING FUNCTIONS (TESTNET ONLY)\n  // ============================================\n  \n  /// @notice Enable/disable test mode\n  /// @dev Only admin can call. Test mode allows level override\n  function setTestMode(bool enabled) external onlyAdmin {\n    testMode = enabled;\n  }\n  \n  /// @notice Set override level (only works in test mode)\n  /// @dev Allows testing app slots without full TVL\n  function setOverrideLevel(uint8 level) external onlyAdmin {\n    require(level <= 3, \"invalid level\");\n    overrideLevel = level;\n  }\n  \n  /// @notice Set time offset for testing\n  /// @dev Allows fast-forwarding time to test cooldowns\n  function setTestTimeOffset(uint256 offset) external onlyAdmin {\n    require(offset <= 365 days, \"offset too large\");\n    testTimeOffset = offset;\n  }\n  \n  /// @notice Reset epoch (allows more exits immediately)\n  /// @dev Useful for testing exit caps\n  function resetEpoch() external onlyAdmin {\n    epochStart = uint64(_currentTime());\n    epochExitedAssets = 0;\n    emit EpochRolled(epochStart);\n  }\n  \n  /// @notice Force complete a redemption request (bypass cooldown)\n  /// @dev TESTNET ONLY - Allows immediate claim for testing\n  function forceCompleteRedemption(uint256 requestId) external onlyAdmin {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"already claimed\");\n    r.unlockTime = uint64(_currentTime());\n  }\n  \n  /// @notice Get current time with offset applied\n  /// @dev Used internally for all time checks\n  function _currentTime() internal view returns (uint256) {\n    return block.timestamp + testTimeOffset;\n  }\n}\n\n\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"},"contracts/contracts/tokens/ERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC20Base\n/// @notice Gas-optimized ERC20 base implementation with assembly optimizations\n/// @dev Uses assembly for critical path operations to minimize gas costs\nabstract contract ERC20Base {\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n  uint256 private _totalSupply;\n\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) { return _name; }\n  function symbol() public view returns (string memory) { return _symbol; }\n  function decimals() public view returns (uint8) { return _decimals; }\n  function totalSupply() public view returns (uint256) { return _totalSupply; }\n  function balanceOf(address account) public view returns (uint256) { return _balances[account]; }\n  function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; }\n\n  function transfer(address to, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[from][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked { _approve(from, msg.sender, currentAllowance - amount); }\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /// @notice Internal transfer function with assembly optimization\n  /// @dev Uses assembly for gas-efficient balance updates\n  /// @param from Address to transfer from\n  /// @param to Address to transfer to\n  /// @param amount Amount to transfer\n  function _transfer(address from, address to, uint256 amount) internal {\n    require(from != address(0) && to != address(0), \"ERC20: zero address\");\n    \n    // Assembly optimized balance operations\n    assembly {\n      // Load balance storage slot for 'from'\n      mstore(0x00, from)\n      mstore(0x20, _balances.slot)\n      let fromBalanceSlot := keccak256(0x00, 0x40)\n      let fromBalance := sload(fromBalanceSlot)\n      \n      // Check sufficient balance\n      if lt(fromBalance, amount) {\n        mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000) // Error selector\n        mstore(0x04, 0x20)\n        mstore(0x24, 27)\n        mstore(0x44, \"ERC20: transfer exceeds balance\")\n        revert(0x00, 0x64)\n      }\n      \n      // Update from balance\n      sstore(fromBalanceSlot, sub(fromBalance, amount))\n      \n      // Load and update balance storage slot for 'to'\n      mstore(0x00, to)\n      let toBalanceSlot := keccak256(0x00, 0x40)\n      let toBalance := sload(toBalanceSlot)\n      sstore(toBalanceSlot, add(toBalance, amount))\n    }\n    \n    emit Transfer(from, to, amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0) && spender != address(0), \"ERC20: zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: mint to zero\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal {\n    uint256 fromBal = _balances[from];\n    require(fromBal >= amount, \"ERC20: burn exceeds balance\");\n    unchecked { _balances[from] = fromBal - amount; }\n    _totalSupply -= amount;\n    emit Transfer(from, address(0), amount);\n  }\n\n  /// @notice Batch transfer tokens to multiple recipients (gas optimized)\n  /// @dev Useful for airdrops and mass distributions\n  /// @param recipients Array of recipient addresses\n  /// @param amounts Array of amounts to transfer\n  /// @return success True if all transfers succeeded\n  function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) public returns (bool success) {\n    uint256 length = recipients.length;\n    require(length == amounts.length, \"ERC20: length mismatch\");\n    \n    for (uint256 i; i < length; ) {\n      _transfer(msg.sender, recipients[i], amounts[i]);\n      unchecked { ++i; }\n    }\n    \n    return true;\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}