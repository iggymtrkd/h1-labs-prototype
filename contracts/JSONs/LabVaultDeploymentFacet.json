{"language":"Solidity","sources":{"contracts/contracts/facets/LabVaultDeploymentFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\n\ncontract LabVaultDeploymentFacet {\n    event LabVaultDeployed(uint256 indexed labId, address indexed owner, address vault, string name, string symbol, string domain);\n    error InvalidInput();\n    error InsufficientStake();\n    error FactoryNotSet();\n    error VaultDeploymentFailed(string reason);\n    error InvalidVaultAddress();\n    \n    struct VaultArgs {\n        address labsToken;\n        string name;\n        string symbol;\n        string domain;\n        uint64 cooldown;\n        uint16 exitCapBps;\n        address owner;\n        address manager;\n        address treasury;\n        address caller;\n    }\n\n    function setVaultFactory(address factory) external {\n        require(factory != address(0), \"Invalid factory\");\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        hs.vaultFactory = factory;\n    }\n\n    function setLabsToken(address labsToken) external {\n        require(labsToken != address(0), \"Invalid LABS token\");\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        hs.labsToken = labsToken;\n    }\n\n    function getLabsToken() external view returns (address) {\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        return hs.labsToken;\n    }\n\n    function createLabStep1(\n        string calldata name,\n        string calldata symbol,\n        string calldata domain\n    ) external returns (uint256 labId, address vault) {\n        // --- Input validation ---\n        if (bytes(name).length == 0 || bytes(name).length > 50) revert InvalidInput();\n        if (bytes(symbol).length == 0 || bytes(symbol).length > 10) revert InvalidInput();\n        if (bytes(domain).length == 0 || bytes(domain).length > 100) revert InvalidInput();\n\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n\n        if (hs.stakedBalances[msg.sender] < 100_000e18) revert InsufficientStake();\n        if (hs.vaultFactory == address(0)) revert FactoryNotSet();\n\n        labId = hs.nextLabId++;\n        hs.labs[labId].owner = msg.sender;\n        hs.labs[labId].domain = domain;\n        hs.labs[labId].active = true;\n        hs.labs[labId].level = _calcLevel(hs.stakedBalances[msg.sender]);\n\n        // --- Prepare args struct ---\n        VaultArgs memory args = VaultArgs({\n            labsToken: hs.labsToken,\n            name: name,\n            symbol: symbol,\n            domain: domain, // FIXED: Use actual domain parameter\n            cooldown: hs.defaultCooldown,\n            exitCapBps: hs.defaultExitCapBps,\n            owner: msg.sender,\n            manager: msg.sender,\n            treasury: hs.protocolTreasury,\n            caller: address(this)\n        });\n\n        vault = _deployVault(hs.vaultFactory, args);\n        \n        if (vault == address(0)) revert InvalidVaultAddress();\n\n        hs.labIdToVault[labId] = vault;\n        hs.labs[labId].h1Token = vault;\n\n        emit LabVaultDeployed(labId, msg.sender, vault, name, symbol, domain);\n    }\n    \n    /// @notice Get lab details (domain)\n    function getLabDetails(uint256 labId) external view returns (address owner, address h1Token, string memory domain, bool active, uint8 level) {\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        LibH1Storage.Lab storage lab = hs.labs[labId];\n        return (lab.owner, lab.h1Token, lab.domain, lab.active, lab.level);\n    }\n\n    function _calcLevel(uint256 bal) private pure returns (uint8) {\n        return bal >= 500_000e18 ? 3 : (bal >= 250_000e18 ? 2 : 1);\n    }\n\n    function _deployVault(address factory, VaultArgs memory args)\n        private\n        returns (address)\n    {\n        // Step 1: Create vault with metadata only\n        (bool ok1, bytes memory data1) = factory.call(\n            abi.encodeWithSignature(\n                \"createVault(string,string,string)\",\n                args.name,\n                args.symbol,\n                args.domain\n            )\n        );\n        \n        if (!ok1) {\n            if (data1.length > 0) {\n                assembly {\n                    let returndata_size := mload(data1)\n                    revert(add(32, data1), returndata_size)\n                }\n            }\n            revert VaultDeploymentFailed(\"Factory createVault call failed\");\n        }\n        \n        address vault = abi.decode(data1, (address));\n        \n        // Step 2: Finalize vault with configuration\n        (bool ok2, bytes memory data2) = factory.call(\n            abi.encodeWithSignature(\n                \"finalizeVault(address,address,uint64,uint16,address,address,address,address)\",\n                vault,\n                args.labsToken,\n                args.cooldown,\n                args.exitCapBps,\n                args.owner,\n                args.manager,\n                args.treasury,\n                args.caller\n            )\n        );\n        \n        if (!ok2) {\n            if (data2.length > 0) {\n                assembly {\n                    let returndata_size := mload(data2)\n                    revert(add(32, data2), returndata_size)\n                }\n            }\n            revert VaultDeploymentFailed(\"Factory finalizeVault call failed\");\n        }\n        \n        return vault;\n    }\n}\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  // ============================================\n  // DEFAULT CONFIGURATION CONSTANTS\n  // ============================================\n  uint64 internal constant DEFAULT_COOLDOWN = 1 days;\n  uint16 internal constant DEFAULT_EXIT_CAP_BPS = 2000; // 20%\n  uint16 internal constant DEFAULT_CURVE_FEE_BPS = 500; // 5%\n  uint16 internal constant DEFAULT_CURVE_POL_BPS = 500; // 5%\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n    uint8 level;            // Level 1-3 based on staked amount (0 = no level)\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  /// @notice Vesting schedule for locked H1 tokens\n  /// @dev Tracks vesting parameters and claim progress\n  struct VestingSchedule {\n    address beneficiary;            // 20 bytes: who receives the tokens\n    uint256 totalAmount;            // 32 bytes: total H1 tokens vesting\n    uint256 claimedAmount;          // 32 bytes: amount already claimed\n    uint256 startTime;              // 32 bytes: vesting start timestamp\n    uint256 duration;               // 32 bytes: vesting duration in seconds\n    uint256 cliffDuration;          // 32 bytes: cliff period before any unlock\n    uint8 vestingType;              // 1 byte: 0=owner, 1=scholar, 2=dev\n    bool revoked;                   // 1 byte: if vesting was revoked\n  }\n\n  /// @notice Initial H1 distribution tracking per lab\n  /// @dev Records how tokens were allocated on lab creation\n  struct H1Distribution {\n    uint256 totalMinted;            // 32 bytes: total H1 minted for this lab\n    uint256 ownerAllocation;        // 32 bytes: 30% to owner (vested)\n    uint256 curveAllocation;        // 32 bytes: 10% to bonding curve (liquid)\n    uint256 scholarAllocation;      // 32 bytes: 40% to scholars (vested)\n    uint256 devAllocation;          // 32 bytes: 15% to devs (vested)\n    uint256 treasuryAllocation;     // 32 bytes: 5% to treasury (instant)\n    uint256 ownerVestingId;         // 32 bytes: vesting schedule ID for owner\n    bool initialized;               // 1 byte: if distribution happened\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n    bool defaultsInitialized;\n    // ============ H1 Vesting & Distribution Storage ============\n    // Vesting schedules\n    mapping(uint256 => VestingSchedule) vestingSchedules;  // vestingId → schedule\n    uint256 nextVestingId;                                  // vestingId counter\n    // Lab H1 distributions\n    mapping(uint256 => H1Distribution) labDistributions;    // labId → distribution\n    // Lab vesting IDs (for scholars and devs)\n    mapping(uint256 => uint256[]) labScholarVestings;       // labId → [vestingIds]\n    mapping(uint256 => uint256[]) labDevVestings;           // labId → [vestingIds]\n    // External factory for vault deployment\n    address vaultFactory;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}