{"language":"Solidity","sources":{"contracts/contracts/facets/LabVaultDeploymentFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\nimport { LibBondingCurveFactory } from \"../libraries/LibBondingCurveFactory.sol\";\nimport { LibH1Distribution } from \"../libraries/LibH1Distribution.sol\";\nimport { LibLabVaultFactory } from \"../libraries/LibLabVaultFactory.sol\";\n\n/// @title LabVaultDeploymentFacet\n/// @notice Handles lab and vault creation in a single transaction\n/// @dev Uses two-step factory calls to avoid stack depth errors\ncontract LabVaultDeploymentFacet {\n    event LabVaultDeployed(uint256 indexed labId, address indexed owner, address vault, string name, string symbol, string domain);\n    event LabDistributionComplete(uint256 indexed labId, address indexed curve);\n    \n    error InvalidInput();\n    error InsufficientStake();\n    error FactoryNotSet();\n    error VaultDeploymentFailed(string reason);\n    error InvalidVaultAddress();\n\n    /// @notice Create a complete lab in ONE transaction (vault + curve + distribution)\n    /// @param name Lab name\n    /// @param symbol H1 token symbol\n    /// @param domain Lab domain\n    function createLab(\n        string calldata name,\n        string calldata symbol,\n        string calldata domain\n    ) external returns (uint256 labId, address vault, address curve) {\n        // --- Input validation ---\n        if (bytes(name).length == 0 || bytes(name).length > 50) revert InvalidInput();\n        if (bytes(symbol).length == 0 || bytes(symbol).length > 10) revert InvalidInput();\n        if (bytes(domain).length == 0 || bytes(domain).length > 100) revert InvalidInput();\n\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n\n        if (hs.stakedBalances[msg.sender] < 100_000e18) revert InsufficientStake();\n        if (hs.vaultFactory == address(0)) revert FactoryNotSet();\n\n        // STEP 1: Create lab entry\n        labId = hs.nextLabId++;\n        hs.labs[labId].owner = msg.sender;\n        hs.labs[labId].domain = domain;\n        hs.labs[labId].active = true;\n        hs.labs[labId].level = _calcLevel(hs.stakedBalances[msg.sender]);\n\n        // Deploy vault using factory\n        vault = LibLabVaultFactory.deployVault(\n            hs.vaultFactory,\n            LibLabVaultFactory.VaultParams({\n                labsToken: hs.labsToken,\n                h1Name: name,\n                h1Symbol: symbol,\n                labDisplayName: domain,\n                cooldownSeconds: hs.defaultCooldown,\n                epochExitCapBps: hs.defaultExitCapBps,\n                admin: msg.sender,\n                labOwner: msg.sender,\n                treasury: hs.protocolTreasury,\n                diamond: address(this)\n            })\n        );\n        if (vault == address(0)) revert InvalidVaultAddress();\n\n        hs.labIdToVault[labId] = vault;\n        hs.labs[labId].h1Token = vault;\n\n        emit LabVaultDeployed(labId, msg.sender, vault, name, symbol, domain);\n\n        // STEP 2: Deploy curve and distribute H1\n        curve = LibBondingCurveFactory.deployBondingCurve(\n            hs.labsToken,\n            vault,\n            hs.protocolTreasury,\n            hs.curveFeeBps,\n            hs.curvePolBps\n        );\n        hs.labIdToCurve[labId] = curve;\n\n        // Distribute H1 tokens\n        LibH1Distribution.distribute(labId, vault, curve, hs.stakedBalances[msg.sender], msg.sender);\n\n        emit LabDistributionComplete(labId, curve);\n    }\n    \n    /// @notice Get lab details\n    function getLabDetails(uint256 labId) external view returns (\n        address owner,\n        address h1Token,\n        string memory domain,\n        bool active,\n        uint8 level\n    ) {\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        LibH1Storage.Lab storage lab = hs.labs[labId];\n        return (lab.owner, lab.h1Token, lab.domain, lab.active, lab.level);\n    }\n\n    /// @notice Set the vault factory address\n    /// @dev Only callable by diamond owner (enforced by storage pattern)\n    function setVaultFactory(address factory) external {\n        require(factory != address(0), \"Invalid factory\");\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        hs.vaultFactory = factory;\n    }\n\n    // ============================================\n    // PRIVATE HELPERS\n    // ============================================\n\n    function _calcLevel(uint256 bal) private pure returns (uint8) {\n        return bal >= 500_000e18 ? 3 : (bal >= 250_000e18 ? 2 : 1);\n    }\n}"},"contracts/contracts/libraries/LibLabVaultFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LabVault } from \"../vaults/LabVault.sol\";\n\n/// @notice Library containing types and constants for LabVault deployment\nlibrary LibLabVaultFactory {\n  /// @notice Constructor parameters struct to avoid stack too deep\n  struct ConstructorParams {\n    address labsToken;\n    string h1Name;\n    string h1Symbol;\n    string labDisplayName;\n    uint64 cooldownSeconds;\n    uint16 epochExitCapBps;\n    address admin;\n    address labOwner;\n    address treasury;\n    address diamond;\n  }\n  \n  // Alias for backward compatibility with existing code\n  struct VaultParams {\n    address labsToken;\n    string h1Name;\n    string h1Symbol;\n    string labDisplayName;\n    uint64 cooldownSeconds;\n    uint16 epochExitCapBps;\n    address admin;\n    address labOwner;\n    address treasury;\n    address diamond;\n  }\n  \n  /// @notice Deploy a vault using the two-step factory pattern\n  /// @param factory Address of LabVaultFactory\n  /// @param params Constructor parameters\n  /// @return vault Address of deployed LabVault\n  function deployVault(address factory, VaultParams memory params) internal returns (address vault) {\n    // Create vault with metadata\n    (bool ok1, bytes memory data1) = factory.call(\n      abi.encodeWithSignature(\n        \"createVault(string,string,string)\",\n        params.h1Name,\n        params.h1Symbol,\n        params.labDisplayName\n      )\n    );\n    require(ok1, \"createVault failed\");\n    vault = abi.decode(data1, (address));\n    \n    // Finalize vault configuration\n    (bool ok2, bytes memory data2) = factory.call(\n      abi.encodeWithSignature(\n        \"finalizeVault(address,address,uint64,uint16,address,address,address,address)\",\n        vault,\n        params.labsToken,\n        params.cooldownSeconds,\n        params.epochExitCapBps,\n        params.admin,\n        params.labOwner,\n        params.treasury,\n        params.diamond\n      )\n    );\n    require(ok2, \"finalizeVault failed\");\n  }\n}\n\n"},"contracts/contracts/libraries/LibH1Distribution.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"./LibH1Storage.sol\";\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\n\ninterface ILabVault {\n  function initialMint(uint256 labsAmount, address[] calldata recipients, uint256[] calldata amounts) external returns (uint256);\n}\n\ninterface IH1VestingFacet {\n  function createVestingSchedule(uint256 labId, address beneficiary, uint256 totalAmount, uint8 vestingType, address vault) external returns (uint256);\n}\n\nlibrary LibH1Distribution {\n  uint256 constant MAX_H1_PER_LAB = 500_000e18;\n  uint8 constant VESTING_TYPE_OWNER = 0;\n\n  event H1Distributed(uint256 indexed labId, uint256 totalH1, uint256 ownerAmount, uint256 curveAmount, uint256 scholarAmount, uint256 devAmount, uint256 treasuryAmount, uint256 ownerVestingId);\n\n  struct Amounts {\n    uint256 total;\n    uint256 owner;\n    uint256 curve;\n    uint256 scholar;\n    uint256 dev;\n    uint256 treasury;\n  }\n\n  function distribute(uint256 labId, address vault, address curve, uint256 stake, address sender) internal {\n    Amounts memory a = _calc(stake);\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    // LABS are already staked in the Diamond, so Diamond already has them\n    // Just approve vault to use them for initial H1 mint\n    require(IERC20(hs.labsToken).approve(vault, a.total), \"APRV\");\n    \n    address curveRecipient = curve == address(0) ? vault : curve;\n    address[] memory r = new address[](5);\n    r[0]=vault; r[1]=curveRecipient; r[2]=vault; r[3]=vault; r[4]=hs.protocolTreasury;\n    uint256[] memory m = new uint256[](5);\n    m[0]=a.owner; m[1]=a.curve; m[2]=a.scholar; m[3]=a.dev; m[4]=a.treasury;\n    ILabVault(vault).initialMint(a.total, r, m);\n    \n    uint256 vid = IH1VestingFacet(address(this)).createVestingSchedule(labId, sender, a.owner, VESTING_TYPE_OWNER, vault);\n    hs.labDistributions[labId] = LibH1Storage.H1Distribution(a.total, a.owner, a.curve, a.scholar, a.dev, a.treasury, vid, true);\n    emit H1Distributed(labId, a.total, a.owner, a.curve, a.scholar, a.dev, a.treasury, vid);\n  }\n\n  function _calc(uint256 bal) private pure returns (Amounts memory) {\n    uint256 t = bal > MAX_H1_PER_LAB ? MAX_H1_PER_LAB : bal;\n    return Amounts(t, t*3000/10000, t*1000/10000, t*4000/10000, t*1500/10000, t*500/10000);\n  }\n}\n\n"},"contracts/contracts/libraries/LibBondingCurveFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { BondingCurveSale } from \"../sales/BondingCurveSale.sol\";\n\nlibrary LibBondingCurveFactory {\n  /// @notice Deploy a bonding curve sale contract\n  /// @param labsToken Address of LABS token\n  /// @param vault Address of lab vault\n  /// @param treasury Address of protocol treasury\n  /// @param feeBps Fee in basis points\n  /// @param polBps Protocol-owned liquidity in basis points\n  /// @return Address of deployed bonding curve\n  function deployBondingCurve(\n    address labsToken,\n    address vault,\n    address treasury,\n    uint16 feeBps,\n    uint16 polBps\n  ) internal returns (address) {\n    return address(new BondingCurveSale(labsToken, vault, treasury, feeBps, polBps));\n  }\n}\n\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  // ============================================\n  // DEFAULT CONFIGURATION CONSTANTS\n  // ============================================\n  uint64 internal constant DEFAULT_COOLDOWN = 1 days;\n  uint16 internal constant DEFAULT_EXIT_CAP_BPS = 2000; // 20%\n  uint16 internal constant DEFAULT_CURVE_FEE_BPS = 500; // 5%\n  uint16 internal constant DEFAULT_CURVE_POL_BPS = 500; // 5%\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n    uint8 level;            // Level 1-3 based on staked amount (0 = no level)\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  /// @notice Vesting schedule for locked H1 tokens\n  /// @dev Tracks vesting parameters and claim progress\n  struct VestingSchedule {\n    address beneficiary;            // 20 bytes: who receives the tokens\n    uint256 totalAmount;            // 32 bytes: total H1 tokens vesting\n    uint256 claimedAmount;          // 32 bytes: amount already claimed\n    uint256 startTime;              // 32 bytes: vesting start timestamp\n    uint256 duration;               // 32 bytes: vesting duration in seconds\n    uint256 cliffDuration;          // 32 bytes: cliff period before any unlock\n    uint8 vestingType;              // 1 byte: 0=owner, 1=scholar, 2=dev\n    bool revoked;                   // 1 byte: if vesting was revoked\n  }\n\n  /// @notice Initial H1 distribution tracking per lab\n  /// @dev Records how tokens were allocated on lab creation\n  struct H1Distribution {\n    uint256 totalMinted;            // 32 bytes: total H1 minted for this lab\n    uint256 ownerAllocation;        // 32 bytes: 30% to owner (vested)\n    uint256 curveAllocation;        // 32 bytes: 10% to bonding curve (liquid)\n    uint256 scholarAllocation;      // 32 bytes: 40% to scholars (vested)\n    uint256 devAllocation;          // 32 bytes: 15% to devs (vested)\n    uint256 treasuryAllocation;     // 32 bytes: 5% to treasury (instant)\n    uint256 ownerVestingId;         // 32 bytes: vesting schedule ID for owner\n    bool initialized;               // 1 byte: if distribution happened\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n    bool defaultsInitialized;\n    // ============ H1 Vesting & Distribution Storage ============\n    // Vesting schedules\n    mapping(uint256 => VestingSchedule) vestingSchedules;  // vestingId → schedule\n    uint256 nextVestingId;                                  // vestingId counter\n    // Lab H1 distributions\n    mapping(uint256 => H1Distribution) labDistributions;    // labId → distribution\n    // Lab vesting IDs (for scholars and devs)\n    mapping(uint256 => uint256[]) labScholarVestings;       // labId → [vestingIds]\n    mapping(uint256 => uint256[]) labDevVestings;           // labId → [vestingIds]\n    // External factory for vault deployment\n    address vaultFactory;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"},"contracts/contracts/vaults/LabVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC20Base } from \"../tokens/ERC20Base.sol\";\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\nimport { LibLabVaultFactory } from \"../libraries/LibLabVaultFactory.sol\";\n\ncontract LabVault is ERC20Base {\n  address public labsToken;\n  string public labDisplayName;\n  address public admin;\n  address public labOwner;           // New: Lab owner receives 1.5% of fees\n  address public treasury;           // New: H1 treasury receives 1% of fees\n\n  uint256 public constant LEVEL1 = 100_000e18;\n  uint256 public constant LEVEL2 = 250_000e18;\n  uint256 public constant LEVEL3 = 500_000e18;\n  uint16 public constant MAX_EXIT_CAP_BPS = 10_000; // 100%\n  uint16 public constant MAX_TOTAL_FEE_BPS = 250;   // 2.5% max total fee (1.5% + 1%)\n\n  uint64 public cooldownSeconds;\n  uint16 public epochExitCapBps;\n  uint64 public epochStart;\n  \n  // Fee configuration (basis points) - Total: 2.5% (1.5% + 1%)\n  uint16 public depositFeeLabOwnerBps = 150;        // 1.5% to lab owner (default)\n  uint16 public depositFeeTreasuryBps = 100;        // 1% to treasury (default)\n  uint16 public redemptionFeeLabOwnerBps = 150;     // 1.5% to lab owner (default)\n  uint16 public redemptionFeeTreasuryBps = 100;     // 1% to treasury (default)\n\n  uint256 public totalAssets;\n  uint256 public pendingExitAssets;\n  uint256 public epochExitedAssets;\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n\n  modifier nonReentrant() {\n    require(status == NOT_ENTERED, \"reentrancy\");\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  // Optimized struct packing: 2 storage slots instead of 4\n  struct RedeemRequest {\n    address owner;      // 20 bytes\n    uint64 unlockTime;  // 8 bytes  \n    bool claimed;       // 1 byte\n    // Total: 29 bytes in slot 1 (3 bytes padding)\n    uint256 assets;     // 32 bytes in slot 2\n  }\n\n  uint256 public nextRequestId;\n  mapping(uint256 => RedeemRequest) public redeemRequests;\n\n  event Deposited(address indexed caller, address indexed receiver, uint256 assets, uint256 shares);\n  event DepositFeeCollected(address indexed caller, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemRequested(uint256 indexed requestId, address indexed owner, uint256 sharesBurned, uint256 assets, uint64 unlockTime);\n  event RedemptionFeeCollected(uint256 indexed requestId, address indexed owner, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemClaimed(uint256 indexed requestId, address indexed owner, uint256 assets);\n  event RedeemCanceled(uint256 indexed requestId, address indexed owner, uint256 assets, uint256 sharesReMinted);\n  event LevelChanged(uint8 newLevel, uint256 totalAssets);\n  event ExitCapsUpdated(uint64 cooldownSeconds, uint16 epochExitCapBps);\n  event EpochRolled(uint64 newEpochStart);\n  event RedeemFilled(uint256 indexed requestId, address indexed filler, uint256 assets, address receiver);\n  event AdminUpdated(address indexed newAdmin);\n  event LabOwnerUpdated(address indexed newLabOwner);\n  event TreasuryUpdated(address indexed newTreasury);\n  event FeesUpdated(uint16 depositLabOwnerBps, uint16 depositTreasuryBps, uint16 redemptionLabOwnerBps, uint16 redemptionTreasuryBps);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n  event InitialMintCompleted(uint256 totalMinted, address indexed diamond);\n\n  error Unauthorized();\n  error InvalidAddress();\n  error InvalidAmount();\n  error InvalidParameter();\n  error ContractPaused();\n  error InitialMintAlreadyCompleted();\n\n  bool private _paused;\n  bool public initialMintCompleted;  // Track if initial H1 distribution happened\n  address public diamond;   // H1Diamond address for auth\n  \n  bool private _initialized;  // Flag to prevent re-initialization\n\n  // Testing variables (TESTNET ONLY)\n  bool public testMode;\n  uint8 public overrideLevel;\n  uint256 public testTimeOffset;\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  constructor() {\n    // Zero-parameter constructor to avoid stack depth issues\n    // All initialization happens in initialize functions\n  }\n\n  /// @notice Initialize vault metadata (step 1)\n  /// @dev Must be called first after deployment\n  function initializeMetadata(\n    string calldata h1Name,\n    string calldata h1Symbol,\n    string calldata labDisplayName_\n  ) external {\n    require(bytes(_name).length == 0, \"metadata already set\");\n    require(bytes(h1Name).length > 0 && bytes(h1Name).length <= 50, \"invalid name\");\n    require(bytes(h1Symbol).length > 0 && bytes(h1Symbol).length <= 10, \"invalid symbol\");\n    \n    // Directly set internal variables to avoid function call overhead\n    _name = h1Name;\n    _symbol = h1Symbol;\n    labDisplayName = labDisplayName_;\n  }\n\n  /// @notice Initialize vault configuration (step 2 and final)\n  /// @dev Must be called after initializeMetadata\n  function initializeConfig(\n    address labsToken_,\n    uint64 cooldownSeconds_,\n    uint16 epochExitCapBps_,\n    address admin_,\n    address labOwner_,\n    address treasury_,\n    address diamond_\n  ) external {\n    require(!_initialized, \"already initialized\");\n    require(labsToken_ != address(0), \"labs token = 0\");\n    require(labOwner_ != address(0), \"lab owner = 0\");\n    require(treasury_ != address(0), \"treasury = 0\");\n    require(diamond_ != address(0), \"diamond = 0\");\n    require(epochExitCapBps_ <= MAX_EXIT_CAP_BPS, \"exit cap > 100%\");\n    \n    _initialized = true;\n    labsToken = labsToken_;\n    cooldownSeconds = cooldownSeconds_;\n    epochExitCapBps = epochExitCapBps_;\n    admin = admin_;\n    labOwner = labOwner_;\n    treasury = treasury_;\n    diamond = diamond_;\n  }\n\n  function assetsPerShare() public view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 1e18;\n    return (totalAssets * 1e18) / supply;\n  }\n\n  function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n    uint256 rate = assetsPerShare();\n    shares = (assets * 1e18) / rate;\n  }\n\n  function previewMint(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  /// @notice Preview deposit accounting for deposit fee\n  function previewDepositWithFee(uint256 assets) public view returns (uint256 shares, uint256 labOwnerFee, uint256 treasuryFee) {\n    labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    shares = previewDeposit(netAssets);\n  }\n\n  /// @notice Preview redemption accounting for redemption fee\n  function previewRedeemWithFee(uint256 shares) public view returns (uint256 assets, uint256 labOwnerFee, uint256 treasuryFee) {\n    assets = previewRedeem(shares);\n    labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n  }\n\n  function getLevel() public view returns (uint8 level) {\n    // If in test mode and override level is set, return it\n    if (testMode && overrideLevel > 0) {\n      return overrideLevel;\n    }\n    \n    // Normal level calculation\n    uint256 a = totalAssets;\n    if (a >= LEVEL3) return 3;\n    if (a >= LEVEL2) return 2;\n    if (a >= LEVEL1) return 1;\n    return 0;\n  }\n\n  function getAppSlots() external view returns (uint8 slots) {\n    uint8 level = getLevel();\n    if (level == 3) return 3;\n    if (level == 2) return 2;\n    if (level == 1) return 1;\n    return 0;\n  }\n\n  /// @notice Initial H1 mint on lab creation (one-time only)\n  /// @dev Called by H1Diamond during lab creation to distribute initial H1 tokens\n  /// @param labsAmount Total LABS backing this H1 issuance\n  /// @param recipients Array of recipient addresses [owner, curve, vault, vault, treasury]\n  /// @param amounts Array of H1 amounts [owner 30%, curve 10%, scholars 40%, devs 15%, treasury 5%]\n  /// @return totalH1Minted Total H1 tokens minted\n  function initialMint(\n    uint256 labsAmount,\n    address[] calldata recipients,\n    uint256[] calldata amounts\n  ) external nonReentrant returns (uint256 totalH1Minted) {\n    // One-time execution guard (called once during lab creation, then blocked forever)\n    if (initialMintCompleted) revert InitialMintAlreadyCompleted();\n    if (recipients.length != 5 || amounts.length != 5) revert InvalidParameter();\n    \n    // Transfer LABS backing from diamond\n    require(\n      IERC20(labsToken).transferFrom(msg.sender, address(this), labsAmount),\n      \"LABS transfer failed\"\n    );\n    \n    // Update vault backing (no fees on initial mint)\n    totalAssets += labsAmount;\n    \n    // Mint H1 tokens to recipients\n    // recipients[0] = vault (owner vesting holder)\n    // recipients[1] = curve (liquid market making)\n    // recipients[2] = vault (scholar reserve holder)\n    // recipients[3] = vault (dev reserve holder)\n    // recipients[4] = treasury (instant distribution)\n    for (uint256 i = 0; i < recipients.length; i++) {\n      if (amounts[i] > 0) {\n        _mint(recipients[i], amounts[i]);\n        totalH1Minted += amounts[i];\n      }\n    }\n    \n    initialMintCompleted = true;\n    emit InitialMintCompleted(totalH1Minted, msg.sender);\n  }\n\n  function depositLABS(uint256 assets, address receiver) external nonReentrant whenNotPaused returns (uint256 shares) {\n    require(assets > 0, \"zero assets\");\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    \n    shares = previewDeposit(netAssets);\n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), assets), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += netAssets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, netAssets, shares);\n  }\n\n  function mintShares(uint256 shares, address receiver) external nonReentrant whenNotPaused returns (uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewMint(shares);\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 totalRequired = assets + (labOwnerFee + treasuryFee);\n    \n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), totalRequired), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += assets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, assets, shares);\n  }\n\n  function requestRedeem(uint256 shares) external nonReentrant whenNotPaused returns (uint256 requestId, uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewRedeem(shares);\n    \n    // Calculate redemption fees\n    uint256 labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n    \n    _rollEpochIfNeeded();\n    _checkAndAccrueExitCap(assets);\n    _burn(msg.sender, shares);\n    pendingExitAssets += assets;\n    uint64 unlockTime = uint64(_currentTime()) + cooldownSeconds;\n    requestId = ++nextRequestId;\n    redeemRequests[requestId] = RedeemRequest({ owner: msg.sender, assets: assets, unlockTime: unlockTime, claimed: false });\n    emit RedemptionFeeCollected(requestId, msg.sender, labOwnerFee, treasuryFee);\n    emit RedeemRequested(requestId, msg.sender, shares, assets, unlockTime);\n  }\n\n  function cancelRedeem(uint256 requestId) external nonReentrant returns (uint256 shares) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(r.owner == msg.sender, \"not owner\");\n    require(!r.claimed, \"claimed\");\n    uint256 assets = r.assets;\n    delete redeemRequests[requestId];\n    pendingExitAssets -= assets;\n    shares = previewDeposit(assets);\n    _mint(msg.sender, shares);\n    emit RedeemCanceled(requestId, msg.sender, assets, shares);\n  }\n\n  function claimRedeem(uint256 requestId) external nonReentrant {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    require(_currentTime() >= r.unlockTime, \"cooldown\");\n    pendingExitAssets -= r.assets;\n    r.claimed = true;\n    totalAssets -= r.assets;\n    \n    // Calculate and apply fees at claim time\n    uint256 labOwnerFee = (r.assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (r.assets * redemptionFeeTreasuryBps) / 10_000;\n    uint256 netAssets = r.assets - (labOwnerFee + treasuryFee);\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    require(IERC20(labsToken).transfer(r.owner, netAssets), \"transfer fail\");\n    _maybeEmitLevelChange();\n    emit RedeemClaimed(requestId, r.owner, netAssets);\n  }\n\n  function fillRedeem(uint256 requestId, address receiver) external nonReentrant returns (uint256 sharesMinted) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    _rollEpochIfNeeded();\n    uint256 assets = r.assets;\n    require(IERC20(labsToken).transferFrom(msg.sender, r.owner, assets), \"fill xfer fail\");\n    pendingExitAssets -= assets;\n    r.claimed = true;\n    sharesMinted = 0;\n    emit RedeemFilled(requestId, msg.sender, assets, receiver);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n\n  function setLabOwner(address newLabOwner) external onlyAdmin {\n    if (newLabOwner == address(0)) revert InvalidAddress();\n    labOwner = newLabOwner;\n    emit LabOwnerUpdated(newLabOwner);\n  }\n\n  function setTreasury(address newTreasury) external onlyAdmin {\n    if (newTreasury == address(0)) revert InvalidAddress();\n    treasury = newTreasury;\n    emit TreasuryUpdated(newTreasury);\n  }\n\n  /// @notice Set deposit and redemption fees (in basis points)\n  /// @dev Both fees must be <= 100 bps (1%)\n  function setFees(uint16 depositLabOwnerBps_, uint16 depositTreasuryBps_, uint16 redemptionLabOwnerBps_, uint16 redemptionTreasuryBps_) external onlyAdmin {\n    require(depositLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"deposit lab owner fee too high\");\n    require(depositTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"deposit treasury fee too high\");\n    require(redemptionLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"redemption lab owner fee too high\");\n    require(redemptionTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"redemption treasury fee too high\");\n    depositFeeLabOwnerBps = depositLabOwnerBps_;\n    depositFeeTreasuryBps = depositTreasuryBps_;\n    redemptionFeeLabOwnerBps = redemptionLabOwnerBps_;\n    redemptionFeeTreasuryBps = redemptionTreasuryBps_;\n    emit FeesUpdated(depositFeeLabOwnerBps, depositFeeTreasuryBps, redemptionFeeLabOwnerBps, redemptionFeeTreasuryBps);\n  }\n\n  function setCooldown(uint64 seconds_) external onlyAdmin {\n    if (seconds_ > 30 days) revert InvalidParameter();\n    cooldownSeconds = seconds_;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  function setEpochExitCapBps(uint16 bps) external onlyAdmin {\n    if (bps > MAX_EXIT_CAP_BPS) revert InvalidParameter();\n    epochExitCapBps = bps;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  /// @notice Emergency pause of vault operations\n  /// @dev Only callable by admin\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause vault operations\n  /// @dev Only callable by admin\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  function _maybeEmitLevelChange() internal {\n    emit LevelChanged(getLevel(), totalAssets);\n  }\n\n  function _rollEpochIfNeeded() internal {\n    if (_currentTime() >= epochStart + 86400) {\n      epochStart = uint64(_currentTime());\n      epochExitedAssets = 0;\n      emit EpochRolled(epochStart);\n    }\n  }\n\n  function _checkAndAccrueExitCap(uint256 assets) internal {\n    uint256 cap = (totalAssets * epochExitCapBps) / 10_000;\n    require(epochExitedAssets + assets <= cap, \"epoch cap\");\n    epochExitedAssets += assets;\n  }\n\n  // ============================================\n  // TESTING FUNCTIONS (TESTNET ONLY)\n  // ============================================\n  \n  /// @notice Enable/disable test mode\n  /// @dev Only admin can call. Test mode allows level override\n  function setTestMode(bool enabled) external onlyAdmin {\n    testMode = enabled;\n  }\n  \n  /// @notice Set override level (only works in test mode)\n  /// @dev Allows testing app slots without full TVL\n  function setOverrideLevel(uint8 level) external onlyAdmin {\n    require(level <= 3, \"invalid level\");\n    overrideLevel = level;\n  }\n  \n  /// @notice Set time offset for testing\n  /// @dev Allows fast-forwarding time to test cooldowns\n  function setTestTimeOffset(uint256 offset) external onlyAdmin {\n    require(offset <= 365 days, \"offset too large\");\n    testTimeOffset = offset;\n  }\n  \n  /// @notice Reset epoch (allows more exits immediately)\n  /// @dev Useful for testing exit caps\n  function resetEpoch() external onlyAdmin {\n    epochStart = uint64(_currentTime());\n    epochExitedAssets = 0;\n    emit EpochRolled(epochStart);\n  }\n  \n  /// @notice Force complete a redemption request (bypass cooldown)\n  /// @dev TESTNET ONLY - Allows immediate claim for testing\n  function forceCompleteRedemption(uint256 requestId) external onlyAdmin {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"already claimed\");\n    r.unlockTime = uint64(_currentTime());\n  }\n  \n  /// @notice Get current time with offset applied\n  /// @dev Used internally for all time checks\n  function _currentTime() internal view returns (uint256) {\n    return block.timestamp + testTimeOffset;\n  }\n}"},"contracts/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20 {\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n  function transfer(address to, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n}\n\n"},"contracts/contracts/sales/BondingCurveSale.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\n\ninterface ILabVaultLike {\n  function depositLABS(uint256 assets, address receiver) external returns (uint256 shares);\n  function assetsPerShare() external view returns (uint256);\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\n/// @title BondingCurveSale\n/// @notice Bonding curve implementation for purchasing lab vault shares\n/// @dev Includes slippage protection and fee caps to prevent exploitation\ncontract BondingCurveSale {\n  address public immutable labsToken;\n  ILabVaultLike public immutable vault;\n  address public immutable treasury;\n\n  uint16 public feeBps;\n  uint16 public polBps;\n  \n  uint16 public constant MAX_FEE_BPS = 1000;  // 10% max fee\n  uint16 public constant MAX_POL_BPS = 1000;  // 10% max POL\n  uint256 private constant BPS_DENOMINATOR = 10_000;\n  uint256 private constant PRICE_PREMIUM_BPS = 1005; // 0.5% premium\n  uint256 private constant PRICE_BASE = 1000;\n  \n  // Price bounds for validation (prevents price manipulation)\n  uint256 public constant MIN_PRICE = 1e15;     // 0.001 LABS minimum\n  uint256 public constant MAX_PRICE = 1e24;     // 1,000,000 LABS maximum\n  uint256 public constant MAX_PRICE_CHANGE_BPS = 5000; // 50% max change per tx\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n  uint256 private lastPrice;\n\n  // Pausable functionality for emergency response\n  bool private _paused;\n  address public admin;\n\n  event Purchased(address indexed buyer, uint256 labsIn, uint256 sharesOut, uint256 feeLabs, uint256 polLabs);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n  event AdminUpdated(address indexed newAdmin);\n\n  error ReentrancyGuard();\n  error InvalidAddress();\n  error InvalidAmount();\n  error SlippageExceeded();\n  error TransferFailed();\n  error FeeTooHigh();\n  error PriceOutOfBounds();\n  error PriceChangeExcessive();\n  error ContractPaused();\n  error Unauthorized();\n\n  modifier nonReentrant() {\n    if (status == ENTERED) revert ReentrancyGuard();\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  constructor(address labsToken_, address vault_, address treasury_, uint16 feeBps_, uint16 polBps_) {\n    if (labsToken_ == address(0) || vault_ == address(0) || treasury_ == address(0)) {\n      revert InvalidAddress();\n    }\n    if (feeBps_ > MAX_FEE_BPS) revert FeeTooHigh();\n    if (polBps_ > MAX_POL_BPS) revert FeeTooHigh();\n    \n    labsToken = labsToken_;\n    vault = ILabVaultLike(vault_);\n    treasury = treasury_;\n    feeBps = feeBps_;\n    polBps = polBps_;\n    admin = msg.sender; // Deployer is initial admin\n  }\n\n  /// @notice Returns current price per share with 0.5% premium\n  /// @dev Price based on vault's NAV with premium factor and validation\n  /// @return Current price per share in LABS tokens\n  function price() public view returns (uint256) {\n    uint256 nav = vault.assetsPerShare();\n    uint256 currentPrice = (nav * PRICE_PREMIUM_BPS) / PRICE_BASE;\n    \n    // Validate price is within bounds\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) {\n      return MIN_PRICE; // Fallback to minimum safe price\n    }\n    \n    return currentPrice;\n  }\n\n  /// @notice Validates price hasn't changed excessively\n  /// @dev Prevents price manipulation attacks\n  /// @param currentPrice Current price to validate\n  function _validatePriceChange(uint256 currentPrice) private {\n    if (lastPrice == 0) {\n      lastPrice = currentPrice;\n      return;\n    }\n    \n    uint256 priceDiff;\n    uint256 changePercentBps;\n    \n    if (currentPrice > lastPrice) {\n      priceDiff = currentPrice - lastPrice;\n      changePercentBps = (priceDiff * BPS_DENOMINATOR) / lastPrice;\n    } else {\n      priceDiff = lastPrice - currentPrice;\n      changePercentBps = (priceDiff * BPS_DENOMINATOR) / lastPrice;\n    }\n    \n    if (changePercentBps > MAX_PRICE_CHANGE_BPS) revert PriceChangeExcessive();\n    lastPrice = currentPrice;\n  }\n\n  /// @notice Purchase vault shares with LABS tokens\n  /// @dev Includes slippage protection via minSharesOut parameter\n  /// @param labsAmount Amount of LABS tokens to spend\n  /// @param receiver Address to receive the vault shares\n  /// @param minSharesOut Minimum shares to receive (slippage protection)\n  /// @return sharesOut Actual amount of shares received\n  /// @custom:reverts InvalidAmount if labsAmount is zero\n  /// @custom:reverts InvalidAddress if receiver is zero address\n  /// @custom:reverts SlippageExceeded if sharesOut < minSharesOut\n  /// @custom:reverts TransferFailed if any token transfer fails\n  /// @custom:reverts ContractPaused if contract is paused\n  function buy(uint256 labsAmount, address receiver, uint256 minSharesOut) external nonReentrant whenNotPaused returns (uint256 sharesOut) {\n    if (labsAmount == 0) revert InvalidAmount();\n    if (receiver == address(0)) revert InvalidAddress();\n    \n    // Validate price before purchase\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n    \n    uint256 fee = (labsAmount * feeBps) / BPS_DENOMINATOR;\n    uint256 pol = (labsAmount * polBps) / BPS_DENOMINATOR;\n    uint256 toDeposit = labsAmount - fee - pol;\n\n    // Transfer tokens from sender\n    if (!IERC20(labsToken).transferFrom(msg.sender, address(this), labsAmount)) {\n      revert TransferFailed();\n    }\n    \n    // Distribute fee to treasury\n    if (fee > 0 && !IERC20(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n    // Route POL to treasury as well (protocol-owned liquidity reserve)\n    if (pol > 0 && !IERC20(labsToken).transfer(treasury, pol)) {\n      revert TransferFailed();\n    }\n    \n    // Approve vault to spend tokens using robust allowance pattern\n    uint256 currentAllowance = IERC20(labsToken).allowance(address(this), address(vault));\n    if (currentAllowance < toDeposit) {\n      // Some ERC20s require zeroing allowance first\n      if (currentAllowance != 0) {\n        if (!IERC20(labsToken).approve(address(vault), 0)) revert TransferFailed();\n      }\n      if (!IERC20(labsToken).approve(address(vault), toDeposit)) revert TransferFailed();\n    }\n    \n    // Deposit to vault and receive shares\n    sharesOut = vault.depositLABS(toDeposit, receiver);\n    \n    // Slippage protection\n    if (sharesOut < minSharesOut) revert SlippageExceeded();\n    \n    emit Purchased(msg.sender, labsAmount, sharesOut, fee, pol);\n  }\n\n  function buyFrom(address buyer, uint256 labsAmount, address receiver, uint256 minSharesOut) external nonReentrant whenNotPaused returns (uint256 sharesOut) {\n    if (labsAmount == 0) revert InvalidAmount();\n    if (buyer == address(0) || receiver == address(0)) revert InvalidAddress();\n    \n    // Validate price before purchase\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n    \n    uint256 fee = (labsAmount * feeBps) / BPS_DENOMINATOR;\n    uint256 pol = (labsAmount * polBps) / BPS_DENOMINATOR;\n    uint256 toDeposit = labsAmount - fee - pol;\n\n    // Transfer tokens from buyer\n    if (!IERC20(labsToken).transferFrom(buyer, address(this), labsAmount)) {\n      revert TransferFailed();\n    }\n    \n    // Distribute fee to treasury\n    if (fee > 0 && !IERC20(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n    // Route POL to treasury as well\n    if (pol > 0 && !IERC20(labsToken).transfer(treasury, pol)) {\n      revert TransferFailed();\n    }\n    \n    // Approve vault to spend tokens using robust allowance pattern\n    uint256 currentAllowance = IERC20(labsToken).allowance(address(this), address(vault));\n    if (currentAllowance < toDeposit) {\n      if (currentAllowance != 0) {\n        if (!IERC20(labsToken).approve(address(vault), 0)) revert TransferFailed();\n      }\n      if (!IERC20(labsToken).approve(address(vault), toDeposit)) revert TransferFailed();\n    }\n    \n    // Deposit to vault and receive shares\n    sharesOut = vault.depositLABS(toDeposit, receiver);\n    \n    // Slippage protection\n    if (sharesOut < minSharesOut) revert SlippageExceeded();\n    \n    emit Purchased(buyer, labsAmount, sharesOut, fee, pol);\n  }\n\n  /// @notice Emergency pause of bonding curve operations\n  /// @dev Only callable by admin to halt trading in security incidents\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause bonding curve operations\n  /// @dev Only callable by admin after security incident is resolved\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  /// @return True if paused, false otherwise\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  /// @notice Sell vault shares back for LABS tokens\n  /// @dev User sells their H1 vault shares to get LABS back\n  /// @param sharesAmount Amount of vault shares to sell\n  /// @param receiver Address to receive LABS tokens\n  /// @param minLabsOut Minimum LABS tokens to receive (slippage protection)\n  /// @return labsOut Actual amount of LABS received\n  function sell(uint256 sharesAmount, address receiver, uint256 minLabsOut) external nonReentrant whenNotPaused returns (uint256 labsOut) {\n    if (sharesAmount == 0) revert InvalidAmount();\n    if (receiver == address(0)) revert InvalidAddress();\n\n    // Validate price before sale\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n\n    // Transfer vault shares from seller to this contract\n    if (!vault.transferFrom(msg.sender, address(this), sharesAmount)) {\n      revert TransferFailed();\n    }\n\n    // Redeem shares from vault to get LABS\n    uint256 labsRedeemed = vault.redeem(sharesAmount, address(this), address(this));\n\n    // Calculate fee\n    uint256 fee = (labsRedeemed * feeBps) / BPS_DENOMINATOR;\n    labsOut = labsRedeemed - fee;\n\n    // Slippage protection\n    if (labsOut < minLabsOut) revert SlippageExceeded();\n\n    // Transfer LABS to receiver\n    if (!IERC20(labsToken).transfer(receiver, labsOut)) {\n      revert TransferFailed();\n    }\n\n    // Transfer fee to treasury\n    if (fee > 0 && !IERC20(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n\n    emit Purchased(receiver, labsRedeemed, sharesAmount, fee, 0);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n  \n  /// @notice Get current bonding curve price for H1 tokens\n  /// @return Current price in LABS tokens\n  function getCurrentPrice() external view returns (uint256) {\n    return price();\n  }\n  \n  /// @notice Get LABS token balance held by the curve\n  /// @return Balance in wei\n  function getLabsBalance() external view returns (uint256) {\n    return IERC20(labsToken).balanceOf(address(this));\n  }\n}\n\n\n"},"contracts/contracts/tokens/ERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC20Base\n/// @notice Gas-optimized ERC20 base implementation\n/// @dev Simplified for Remix compilation compatibility\nabstract contract ERC20Base {\n  string internal _name;\n  string internal _symbol;\n  uint8 internal _decimals;\n  uint256 internal _totalSupply;\n\n  mapping(address => uint256) internal _balances;\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  constructor() {\n    // Zero-parameter constructor to avoid stack depth issues\n    // Subclasses can directly set _name and _symbol (internal access)\n    _decimals = 18;\n  }\n\n  function name() public view returns (string memory) { return _name; }\n  function symbol() public view returns (string memory) { return _symbol; }\n  function decimals() public view returns (uint8) { return _decimals; }\n  function totalSupply() public view returns (uint256) { return _totalSupply; }\n  function balanceOf(address account) public view returns (uint256) { return _balances[account]; }\n  function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; }\n\n  function transfer(address to, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[from][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked { _approve(from, msg.sender, currentAllowance - amount); }\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /// @notice Internal transfer function\n  /// @dev Simplified for stack depth compatibility\n  /// @param from Address to transfer from\n  /// @param to Address to transfer to\n  /// @param amount Amount to transfer\n  function _transfer(address from, address to, uint256 amount) internal {\n    require(from != address(0) && to != address(0), \"ERC20: zero address\");\n    require(_balances[from] >= amount, \"ERC20: transfer exceeds balance\");\n    \n    unchecked {\n      _balances[from] -= amount;\n      _balances[to] += amount;\n    }\n    \n    emit Transfer(from, to, amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0) && spender != address(0), \"ERC20: zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: mint to zero\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal {\n    uint256 fromBal = _balances[from];\n    require(fromBal >= amount, \"ERC20: burn exceeds balance\");\n    unchecked { _balances[from] = fromBal - amount; }\n    _totalSupply -= amount;\n    emit Transfer(from, address(0), amount);\n  }\n\n  /// @notice Batch transfer tokens to multiple recipients\n  /// @dev Useful for airdrops and mass distributions\n  /// @param recipients Array of recipient addresses\n  /// @param amounts Array of amounts to transfer\n  /// @return success True if all transfers succeeded\n  function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) public returns (bool success) {\n    uint256 length = recipients.length;\n    require(length == amounts.length, \"ERC20: length mismatch\");\n    \n    for (uint256 i; i < length; ) {\n      _transfer(msg.sender, recipients[i], amounts[i]);\n      unchecked { ++i; }\n    }\n    \n    return true;\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":1200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}