{"language":"Solidity","sources":{"contracts/contracts/facets/LabVaultDeploymentFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\nimport { LibBondingCurveFactory } from \"../libraries/LibBondingCurveFactory.sol\";\nimport { LibH1Distribution } from \"../libraries/LibH1Distribution.sol\";\n\n/// @title LabVaultDeploymentFacet\n/// @notice Handles lab and vault creation in a single transaction\n/// @dev Uses two-step factory calls to avoid stack depth errors\ncontract LabVaultDeploymentFacet {\n    event LabVaultDeployed(uint256 indexed labId, address indexed owner, address vault, string name, string symbol, string domain);\n    event LabDistributionComplete(uint256 indexed labId, address indexed curve);\n    \n    error InvalidInput();\n    error InsufficientStake();\n    error FactoryNotSet();\n    error VaultDeploymentFailed(string reason);\n    error InvalidVaultAddress();\n\n    /// @notice Create a complete lab in ONE transaction (vault + curve + distribution)\n    /// @param name Lab name\n    /// @param symbol H1 token symbol\n    /// @param domain Lab domain\n    function createLab(\n        string calldata name,\n        string calldata symbol,\n        string calldata domain\n    ) external returns (uint256 labId, address vault, address curve) {\n        // --- Input validation ---\n        if (bytes(name).length == 0 || bytes(name).length > 50) revert InvalidInput();\n        if (bytes(symbol).length == 0 || bytes(symbol).length > 10) revert InvalidInput();\n        if (bytes(domain).length == 0 || bytes(domain).length > 100) revert InvalidInput();\n\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n\n        if (hs.stakedBalances[msg.sender] < 100_000e18) revert InsufficientStake();\n        if (hs.vaultFactory == address(0)) revert FactoryNotSet();\n\n        // STEP 1: Create lab entry\n        labId = hs.nextLabId++;\n        hs.labs[labId].owner = msg.sender;\n        hs.labs[labId].domain = domain;\n        hs.labs[labId].active = true;\n        hs.labs[labId].level = _calcLevel(hs.stakedBalances[msg.sender]);\n\n        // Deploy vault using factory\n        vault = _deployVault(hs.vaultFactory, name, symbol, domain, hs);\n        if (vault == address(0)) revert InvalidVaultAddress();\n\n        hs.labIdToVault[labId] = vault;\n        hs.labs[labId].h1Token = vault;\n\n        emit LabVaultDeployed(labId, msg.sender, vault, name, symbol, domain);\n\n        // STEP 2: Deploy curve and distribute H1\n        curve = LibBondingCurveFactory.deployBondingCurve(\n            hs.labsToken,\n            vault,\n            hs.protocolTreasury,\n            hs.curveFeeBps,\n            hs.curvePolBps\n        );\n        hs.labIdToCurve[labId] = curve;\n\n        // Distribute H1 tokens\n        LibH1Distribution.distribute(labId, vault, curve, hs.stakedBalances[msg.sender], msg.sender);\n\n        emit LabDistributionComplete(labId, curve);\n    }\n    \n    /// @notice Get lab details\n    function getLabDetails(uint256 labId) external view returns (\n        address owner,\n        address h1Token,\n        string memory domain,\n        bool active,\n        uint8 level\n    ) {\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        LibH1Storage.Lab storage lab = hs.labs[labId];\n        return (lab.owner, lab.h1Token, lab.domain, lab.active, lab.level);\n    }\n\n    /// @notice Set the vault factory address\n    /// @dev Only callable by diamond owner (enforced by storage pattern)\n    function setVaultFactory(address factory) external {\n        require(factory != address(0), \"Invalid factory\");\n        LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n        hs.vaultFactory = factory;\n    }\n\n    // ============================================\n    // PRIVATE HELPERS\n    // ============================================\n\n    function _calcLevel(uint256 bal) private pure returns (uint8) {\n        return bal >= 500_000e18 ? 3 : (bal >= 250_000e18 ? 2 : 1);\n    }\n\n    /// @notice Deploy vault using factory's two-step pattern\n    /// @dev Calls createVault then finalizeVault to avoid stack depth\n    /// @dev address(this) is the diamond in delegatecall context\n    function _deployVault(\n        address factory,\n        string calldata name,\n        string calldata symbol,\n        string calldata domain,\n        LibH1Storage.H1Storage storage hs\n    ) private returns (address vault) {\n        // Step 1: Create vault with metadata\n        (bool ok1, bytes memory data1) = factory.call(\n            abi.encodeWithSignature(\n                \"createVault(string,string,string)\",\n                name,\n                symbol,\n                domain\n            )\n        );\n        \n        if (!ok1) {\n            if (data1.length > 0) {\n                assembly {\n                    let returndata_size := mload(data1)\n                    revert(add(32, data1), returndata_size)\n                }\n            }\n            revert VaultDeploymentFailed(\"Factory createVault call failed\");\n        }\n        \n        vault = abi.decode(data1, (address));\n        \n        // Step 2: Finalize vault configuration\n        // address(this) = diamond (in delegatecall context of facet)\n        (bool ok2, bytes memory data2) = factory.call(\n            abi.encodeWithSignature(\n                \"finalizeVault(address,address,uint64,uint16,address,address,address,address)\",\n                vault,\n                hs.labsToken,\n                hs.defaultCooldown,\n                hs.defaultExitCapBps,\n                msg.sender,           // admin\n                msg.sender,           // labOwner\n                hs.protocolTreasury,  // treasury\n                address(this)         // diamond reference for vault\n            )\n        );\n        \n        if (!ok2) {\n            if (data2.length > 0) {\n                assembly {\n                    let returndata_size := mload(data2)\n                    revert(add(32, data2), returndata_size)\n                }\n            }\n            revert VaultDeploymentFailed(\"Factory finalizeVault call failed\");\n        }\n    }\n}"},"contracts/contracts/libraries/LibH1Distribution.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"./LibH1Storage.sol\";\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\n\ninterface ILabVault {\n  function initialMint(uint256 labsAmount, address[] calldata recipients, uint256[] calldata amounts) external returns (uint256);\n}\n\ninterface IH1VestingFacet {\n  function createVestingSchedule(uint256 labId, address beneficiary, uint256 totalAmount, uint8 vestingType, address vault) external returns (uint256);\n}\n\nlibrary LibH1Distribution {\n  uint256 constant MAX_H1_PER_LAB = 500_000e18;\n  uint8 constant VESTING_TYPE_OWNER = 0;\n\n  event H1Distributed(uint256 indexed labId, uint256 totalH1, uint256 ownerAmount, uint256 curveAmount, uint256 scholarAmount, uint256 devAmount, uint256 treasuryAmount, uint256 ownerVestingId);\n\n  struct Amounts {\n    uint256 total;\n    uint256 owner;\n    uint256 curve;\n    uint256 scholar;\n    uint256 dev;\n    uint256 treasury;\n  }\n\n  function distribute(uint256 labId, address vault, address curve, uint256 stake, address sender) internal {\n    Amounts memory a = _calc(stake);\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    \n    // LABS are already staked in the Diamond, so Diamond already has them\n    // Just approve vault to use them for initial H1 mint\n    require(IERC20(hs.labsToken).approve(vault, a.total), \"APRV\");\n    \n    address curveRecipient = curve == address(0) ? vault : curve;\n    address[] memory r = new address[](5);\n    r[0]=vault; r[1]=curveRecipient; r[2]=vault; r[3]=vault; r[4]=hs.protocolTreasury;\n    uint256[] memory m = new uint256[](5);\n    m[0]=a.owner; m[1]=a.curve; m[2]=a.scholar; m[3]=a.dev; m[4]=a.treasury;\n    ILabVault(vault).initialMint(a.total, r, m);\n    \n    uint256 vid = IH1VestingFacet(address(this)).createVestingSchedule(labId, sender, a.owner, VESTING_TYPE_OWNER, vault);\n    hs.labDistributions[labId] = LibH1Storage.H1Distribution(a.total, a.owner, a.curve, a.scholar, a.dev, a.treasury, vid, true);\n    emit H1Distributed(labId, a.total, a.owner, a.curve, a.scholar, a.dev, a.treasury, vid);\n  }\n\n  function _calc(uint256 bal) private pure returns (Amounts memory) {\n    uint256 t = bal > MAX_H1_PER_LAB ? MAX_H1_PER_LAB : bal;\n    return Amounts(t, t*3000/10000, t*1000/10000, t*4000/10000, t*1500/10000, t*500/10000);\n  }\n}\n\n"},"contracts/contracts/libraries/LibBondingCurveFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { BondingCurveSale } from \"../sales/BondingCurveSale.sol\";\n\nlibrary LibBondingCurveFactory {\n  /// @notice Deploy a bonding curve sale contract\n  /// @param labsToken Address of LABS token\n  /// @param vault Address of lab vault\n  /// @param treasury Address of protocol treasury\n  /// @param feeBps Fee in basis points\n  /// @param polBps Protocol-owned liquidity in basis points\n  /// @return Address of deployed bonding curve\n  function deployBondingCurve(\n    address labsToken,\n    address vault,\n    address treasury,\n    uint16 feeBps,\n    uint16 polBps\n  ) internal returns (address) {\n    return address(new BondingCurveSale(labsToken, vault, treasury, feeBps, polBps));\n  }\n}\n\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  // ============================================\n  // DEFAULT CONFIGURATION CONSTANTS\n  // ============================================\n  uint64 internal constant DEFAULT_COOLDOWN = 1 days;\n  uint16 internal constant DEFAULT_EXIT_CAP_BPS = 2000; // 20%\n  uint16 internal constant DEFAULT_CURVE_FEE_BPS = 500; // 5%\n  uint16 internal constant DEFAULT_CURVE_POL_BPS = 500; // 5%\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n    uint8 level;            // Level 1-3 based on staked amount (0 = no level)\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  /// @notice Vesting schedule for locked H1 tokens\n  /// @dev Tracks vesting parameters and claim progress\n  struct VestingSchedule {\n    address beneficiary;            // 20 bytes: who receives the tokens\n    uint256 totalAmount;            // 32 bytes: total H1 tokens vesting\n    uint256 claimedAmount;          // 32 bytes: amount already claimed\n    uint256 startTime;              // 32 bytes: vesting start timestamp\n    uint256 duration;               // 32 bytes: vesting duration in seconds\n    uint256 cliffDuration;          // 32 bytes: cliff period before any unlock\n    uint8 vestingType;              // 1 byte: 0=owner, 1=scholar, 2=dev\n    bool revoked;                   // 1 byte: if vesting was revoked\n  }\n\n  /// @notice Initial H1 distribution tracking per lab\n  /// @dev Records how tokens were allocated on lab creation\n  struct H1Distribution {\n    uint256 totalMinted;            // 32 bytes: total H1 minted for this lab\n    uint256 ownerAllocation;        // 32 bytes: 30% to owner (vested)\n    uint256 curveAllocation;        // 32 bytes: 10% to bonding curve (liquid)\n    uint256 scholarAllocation;      // 32 bytes: 40% to scholars (vested)\n    uint256 devAllocation;          // 32 bytes: 15% to devs (vested)\n    uint256 treasuryAllocation;     // 32 bytes: 5% to treasury (instant)\n    uint256 ownerVestingId;         // 32 bytes: vesting schedule ID for owner\n    bool initialized;               // 1 byte: if distribution happened\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n    bool defaultsInitialized;\n    // ============ H1 Vesting & Distribution Storage ============\n    // Vesting schedules\n    mapping(uint256 => VestingSchedule) vestingSchedules;  // vestingId → schedule\n    uint256 nextVestingId;                                  // vestingId counter\n    // Lab H1 distributions\n    mapping(uint256 => H1Distribution) labDistributions;    // labId → distribution\n    // Lab vesting IDs (for scholars and devs)\n    mapping(uint256 => uint256[]) labScholarVestings;       // labId → [vestingIds]\n    mapping(uint256 => uint256[]) labDevVestings;           // labId → [vestingIds]\n    // External factory for vault deployment\n    address vaultFactory;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"},"contracts/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20 {\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n  function transfer(address to, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n}\n\n"},"contracts/contracts/sales/BondingCurveSale.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\n\ninterface ILabVaultLike {\n  function depositLABS(uint256 assets, address receiver) external returns (uint256 shares);\n  function assetsPerShare() external view returns (uint256);\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\n/// @title BondingCurveSale\n/// @notice Bonding curve implementation for purchasing lab vault shares\n/// @dev Includes slippage protection and fee caps to prevent exploitation\ncontract BondingCurveSale {\n  address public immutable labsToken;\n  ILabVaultLike public immutable vault;\n  address public immutable treasury;\n\n  uint16 public feeBps;\n  uint16 public polBps;\n  \n  uint16 public constant MAX_FEE_BPS = 1000;  // 10% max fee\n  uint16 public constant MAX_POL_BPS = 1000;  // 10% max POL\n  uint256 private constant BPS_DENOMINATOR = 10_000;\n  uint256 private constant PRICE_PREMIUM_BPS = 1005; // 0.5% premium\n  uint256 private constant PRICE_BASE = 1000;\n  \n  // Price bounds for validation (prevents price manipulation)\n  uint256 public constant MIN_PRICE = 1e15;     // 0.001 LABS minimum\n  uint256 public constant MAX_PRICE = 1e24;     // 1,000,000 LABS maximum\n  uint256 public constant MAX_PRICE_CHANGE_BPS = 5000; // 50% max change per tx\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n  uint256 private lastPrice;\n\n  // Pausable functionality for emergency response\n  bool private _paused;\n  address public admin;\n\n  event Purchased(address indexed buyer, uint256 labsIn, uint256 sharesOut, uint256 feeLabs, uint256 polLabs);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n  event AdminUpdated(address indexed newAdmin);\n\n  error ReentrancyGuard();\n  error InvalidAddress();\n  error InvalidAmount();\n  error SlippageExceeded();\n  error TransferFailed();\n  error FeeTooHigh();\n  error PriceOutOfBounds();\n  error PriceChangeExcessive();\n  error ContractPaused();\n  error Unauthorized();\n\n  modifier nonReentrant() {\n    if (status == ENTERED) revert ReentrancyGuard();\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  constructor(address labsToken_, address vault_, address treasury_, uint16 feeBps_, uint16 polBps_) {\n    if (labsToken_ == address(0) || vault_ == address(0) || treasury_ == address(0)) {\n      revert InvalidAddress();\n    }\n    if (feeBps_ > MAX_FEE_BPS) revert FeeTooHigh();\n    if (polBps_ > MAX_POL_BPS) revert FeeTooHigh();\n    \n    labsToken = labsToken_;\n    vault = ILabVaultLike(vault_);\n    treasury = treasury_;\n    feeBps = feeBps_;\n    polBps = polBps_;\n    admin = msg.sender; // Deployer is initial admin\n  }\n\n  /// @notice Returns current price per share with 0.5% premium\n  /// @dev Price based on vault's NAV with premium factor and validation\n  /// @return Current price per share in LABS tokens\n  function price() public view returns (uint256) {\n    uint256 nav = vault.assetsPerShare();\n    uint256 currentPrice = (nav * PRICE_PREMIUM_BPS) / PRICE_BASE;\n    \n    // Validate price is within bounds\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) {\n      return MIN_PRICE; // Fallback to minimum safe price\n    }\n    \n    return currentPrice;\n  }\n\n  /// @notice Validates price hasn't changed excessively\n  /// @dev Prevents price manipulation attacks\n  /// @param currentPrice Current price to validate\n  function _validatePriceChange(uint256 currentPrice) private {\n    if (lastPrice == 0) {\n      lastPrice = currentPrice;\n      return;\n    }\n    \n    uint256 priceDiff;\n    uint256 changePercentBps;\n    \n    if (currentPrice > lastPrice) {\n      priceDiff = currentPrice - lastPrice;\n      changePercentBps = (priceDiff * BPS_DENOMINATOR) / lastPrice;\n    } else {\n      priceDiff = lastPrice - currentPrice;\n      changePercentBps = (priceDiff * BPS_DENOMINATOR) / lastPrice;\n    }\n    \n    if (changePercentBps > MAX_PRICE_CHANGE_BPS) revert PriceChangeExcessive();\n    lastPrice = currentPrice;\n  }\n\n  /// @notice Purchase vault shares with LABS tokens\n  /// @dev Includes slippage protection via minSharesOut parameter\n  /// @param labsAmount Amount of LABS tokens to spend\n  /// @param receiver Address to receive the vault shares\n  /// @param minSharesOut Minimum shares to receive (slippage protection)\n  /// @return sharesOut Actual amount of shares received\n  /// @custom:reverts InvalidAmount if labsAmount is zero\n  /// @custom:reverts InvalidAddress if receiver is zero address\n  /// @custom:reverts SlippageExceeded if sharesOut < minSharesOut\n  /// @custom:reverts TransferFailed if any token transfer fails\n  /// @custom:reverts ContractPaused if contract is paused\n  function buy(uint256 labsAmount, address receiver, uint256 minSharesOut) external nonReentrant whenNotPaused returns (uint256 sharesOut) {\n    if (labsAmount == 0) revert InvalidAmount();\n    if (receiver == address(0)) revert InvalidAddress();\n    \n    // Validate price before purchase\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n    \n    uint256 fee = (labsAmount * feeBps) / BPS_DENOMINATOR;\n    uint256 pol = (labsAmount * polBps) / BPS_DENOMINATOR;\n    uint256 toDeposit = labsAmount - fee - pol;\n\n    // Transfer tokens from sender\n    if (!IERC20(labsToken).transferFrom(msg.sender, address(this), labsAmount)) {\n      revert TransferFailed();\n    }\n    \n    // Distribute fee to treasury\n    if (fee > 0 && !IERC20(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n    // Route POL to treasury as well (protocol-owned liquidity reserve)\n    if (pol > 0 && !IERC20(labsToken).transfer(treasury, pol)) {\n      revert TransferFailed();\n    }\n    \n    // Approve vault to spend tokens using robust allowance pattern\n    uint256 currentAllowance = IERC20(labsToken).allowance(address(this), address(vault));\n    if (currentAllowance < toDeposit) {\n      // Some ERC20s require zeroing allowance first\n      if (currentAllowance != 0) {\n        if (!IERC20(labsToken).approve(address(vault), 0)) revert TransferFailed();\n      }\n      if (!IERC20(labsToken).approve(address(vault), toDeposit)) revert TransferFailed();\n    }\n    \n    // Deposit to vault and receive shares\n    sharesOut = vault.depositLABS(toDeposit, receiver);\n    \n    // Slippage protection\n    if (sharesOut < minSharesOut) revert SlippageExceeded();\n    \n    emit Purchased(msg.sender, labsAmount, sharesOut, fee, pol);\n  }\n\n  function buyFrom(address buyer, uint256 labsAmount, address receiver, uint256 minSharesOut) external nonReentrant whenNotPaused returns (uint256 sharesOut) {\n    if (labsAmount == 0) revert InvalidAmount();\n    if (buyer == address(0) || receiver == address(0)) revert InvalidAddress();\n    \n    // Validate price before purchase\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n    \n    uint256 fee = (labsAmount * feeBps) / BPS_DENOMINATOR;\n    uint256 pol = (labsAmount * polBps) / BPS_DENOMINATOR;\n    uint256 toDeposit = labsAmount - fee - pol;\n\n    // Transfer tokens from buyer\n    if (!IERC20(labsToken).transferFrom(buyer, address(this), labsAmount)) {\n      revert TransferFailed();\n    }\n    \n    // Distribute fee to treasury\n    if (fee > 0 && !IERC20(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n    // Route POL to treasury as well\n    if (pol > 0 && !IERC20(labsToken).transfer(treasury, pol)) {\n      revert TransferFailed();\n    }\n    \n    // Approve vault to spend tokens using robust allowance pattern\n    uint256 currentAllowance = IERC20(labsToken).allowance(address(this), address(vault));\n    if (currentAllowance < toDeposit) {\n      if (currentAllowance != 0) {\n        if (!IERC20(labsToken).approve(address(vault), 0)) revert TransferFailed();\n      }\n      if (!IERC20(labsToken).approve(address(vault), toDeposit)) revert TransferFailed();\n    }\n    \n    // Deposit to vault and receive shares\n    sharesOut = vault.depositLABS(toDeposit, receiver);\n    \n    // Slippage protection\n    if (sharesOut < minSharesOut) revert SlippageExceeded();\n    \n    emit Purchased(buyer, labsAmount, sharesOut, fee, pol);\n  }\n\n  /// @notice Emergency pause of bonding curve operations\n  /// @dev Only callable by admin to halt trading in security incidents\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause bonding curve operations\n  /// @dev Only callable by admin after security incident is resolved\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  /// @return True if paused, false otherwise\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  /// @notice Sell vault shares back for LABS tokens\n  /// @dev User sells their H1 vault shares to get LABS back\n  /// @param sharesAmount Amount of vault shares to sell\n  /// @param receiver Address to receive LABS tokens\n  /// @param minLabsOut Minimum LABS tokens to receive (slippage protection)\n  /// @return labsOut Actual amount of LABS received\n  function sell(uint256 sharesAmount, address receiver, uint256 minLabsOut) external nonReentrant whenNotPaused returns (uint256 labsOut) {\n    if (sharesAmount == 0) revert InvalidAmount();\n    if (receiver == address(0)) revert InvalidAddress();\n\n    // Validate price before sale\n    uint256 currentPrice = price();\n    if (currentPrice < MIN_PRICE || currentPrice > MAX_PRICE) revert PriceOutOfBounds();\n    _validatePriceChange(currentPrice);\n\n    // Transfer vault shares from seller to this contract\n    if (!vault.transferFrom(msg.sender, address(this), sharesAmount)) {\n      revert TransferFailed();\n    }\n\n    // Redeem shares from vault to get LABS\n    uint256 labsRedeemed = vault.redeem(sharesAmount, address(this), address(this));\n\n    // Calculate fee\n    uint256 fee = (labsRedeemed * feeBps) / BPS_DENOMINATOR;\n    labsOut = labsRedeemed - fee;\n\n    // Slippage protection\n    if (labsOut < minLabsOut) revert SlippageExceeded();\n\n    // Transfer LABS to receiver\n    if (!IERC20(labsToken).transfer(receiver, labsOut)) {\n      revert TransferFailed();\n    }\n\n    // Transfer fee to treasury\n    if (fee > 0 && !IERC20(labsToken).transfer(treasury, fee)) {\n      revert TransferFailed();\n    }\n\n    emit Purchased(receiver, labsRedeemed, sharesAmount, fee, 0);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n  \n  /// @notice Get current bonding curve price for H1 tokens\n  /// @return Current price in LABS tokens\n  function getCurrentPrice() external view returns (uint256) {\n    return price();\n  }\n  \n  /// @notice Get LABS token balance held by the curve\n  /// @return Balance in wei\n  function getLabsBalance() external view returns (uint256) {\n    return IERC20(labsToken).balanceOf(address(this));\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}