{"language":"Solidity","sources":{"contracts/facets/RevenueFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\n\n/// @title RevenueFacet\n/// @notice Handles revenue distribution for labs with per-dataset, per-lab tracking\n/// @dev Implements checks-effects-interactions pattern with custom reentrancy guard\ncontract RevenueFacet {\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n\n  // Revenue distribution percentages (in basis points) - Total: 100%\n  uint256 private constant BUYBACK_H1_HOLDERS_BPS = 4000;       // 40% - Buyback for lab's H1 holders\n  uint256 private constant APP_DEVELOPER_BPS = 1500;            // 15% - App/SDK developer incentive\n  uint256 private constant DATA_CREATORS_BPS = 2000;            // 20% - Data creators/collectors\n  uint256 private constant SCHOLARS_BPS = 2000;                 // 20% - Scholars/supervisors who validated\n  uint256 private constant H1_TREASURY_BPS = 500;               // 5% - H1 protocol treasury\n  uint256 private constant BPS_DENOMINATOR = 10000;\n\n  event RevenueDistributed(\n    uint256 indexed datasetId,\n    uint256 indexed labId,\n    uint256 buybackAmount,\n    uint256 developerAmount,\n    uint256 creatorAmount,\n    uint256 scholarAmount,\n    uint256 treasuryAmount\n  );\n\n  event BatchRevenueDistributed(\n    uint256[] datasetIds,\n    uint256[] labIds,\n    uint256 totalAmount,\n    uint256 timestamp\n  );\n\n  error ReentrancyGuard();\n  error InvalidLabId();\n  error InvalidAmount();\n  error TransferFailed();\n  error ArrayLengthMismatch();\n  error InvalidDatasetCount();\n\n  modifier nonReentrant() {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    if (hs.reentrancyStatus == ENTERED) revert ReentrancyGuard();\n    hs.reentrancyStatus = ENTERED;\n    _;\n    hs.reentrancyStatus = NOT_ENTERED;\n  }\n\n  /// @notice Batch distribute revenue from dataset purchases with per-dataset, per-lab tracking\n  /// @dev Processes dataset marketplace purchases with automatic revenue splitting\n  /// @param datasetIds Array of dataset IDs being purchased\n  /// @param labIds Array of lab IDs (one per dataset, must match dataset's lab)\n  /// @param amounts Array of amounts for each dataset (must match array lengths)\n  function batchDistributeRevenue(\n    uint256[] calldata datasetIds,\n    uint256[] calldata labIds,\n    uint256[] calldata amounts\n  ) external payable nonReentrant {\n    if (datasetIds.length != labIds.length || labIds.length != amounts.length) {\n      revert ArrayLengthMismatch();\n    }\n    if (labIds.length == 0) revert InvalidDatasetCount();\n\n    // Calculate and validate total amount\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < amounts.length; i++) {\n      if (amounts[i] == 0) revert InvalidAmount();\n      totalAmount += amounts[i];\n    }\n\n    if (msg.value != totalAmount) revert InvalidAmount();\n\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    address treasury = hs.protocolTreasury;\n\n    // Process each dataset purchase with per-lab, per-dataset revenue distribution\n    for (uint256 i = 0; i < datasetIds.length; i++) {\n      uint256 datasetId = datasetIds[i];\n      uint256 labId = labIds[i];\n      uint256 amount = amounts[i];\n\n      LibH1Storage.Lab storage lab = hs.labs[labId];\n      if (lab.owner == address(0)) revert InvalidLabId();\n\n      // Calculate distribution (100% split):\n      // 40% - Buyback for lab's H1 holders (increases NAV via supply reduction)\n      // 15% - App developer incentive\n      // 20% - Data creators/collectors\n      // 20% - Scholars/supervisors who validated\n      // 5% - H1 protocol treasury\n      \n      uint256 buybackAmount = (amount * BUYBACK_H1_HOLDERS_BPS) / BPS_DENOMINATOR;\n      uint256 developerAmount = (amount * APP_DEVELOPER_BPS) / BPS_DENOMINATOR;\n      uint256 creatorAmount = (amount * DATA_CREATORS_BPS) / BPS_DENOMINATOR;\n      uint256 scholarAmount = (amount * SCHOLARS_BPS) / BPS_DENOMINATOR;\n      uint256 treasuryAmount = (amount * H1_TREASURY_BPS) / BPS_DENOMINATOR;\n\n      // Update lab state\n      lab.totalRevenue += amount;\n\n      // Distribute buyback reserve to treasury for H1 repurchase execution\n      if (treasury != address(0) && buybackAmount > 0) {\n        (bool successBuyback, ) = payable(treasury).call{value: buybackAmount}(\"\");\n        if (!successBuyback) revert TransferFailed();\n      }\n\n      // Distribute developer incentive to treasury for later payout\n      if (treasury != address(0) && developerAmount > 0) {\n        (bool successDeveloper, ) = payable(treasury).call{value: developerAmount}(\"\");\n        if (!successDeveloper) revert TransferFailed();\n      }\n\n      // Distribute creator share to treasury for later distribution\n      if (treasury != address(0) && creatorAmount > 0) {\n        (bool successCreator, ) = payable(treasury).call{value: creatorAmount}(\"\");\n        if (!successCreator) revert TransferFailed();\n      }\n\n      // Distribute scholar share to treasury for later distribution\n      if (treasury != address(0) && scholarAmount > 0) {\n        (bool successScholar, ) = payable(treasury).call{value: scholarAmount}(\"\");\n        if (!successScholar) revert TransferFailed();\n      }\n\n      // Distribute H1 treasury fee\n      if (treasury != address(0) && treasuryAmount > 0) {\n        (bool successTreasury, ) = payable(treasury).call{value: treasuryAmount}(\"\");\n        if (!successTreasury) revert TransferFailed();\n      }\n\n      emit RevenueDistributed(\n        datasetId,\n        labId,\n        buybackAmount,\n        developerAmount,\n        creatorAmount,\n        scholarAmount,\n        treasuryAmount\n      );\n    }\n\n    // Emit batch completion event\n    emit BatchRevenueDistributed(datasetIds, labIds, totalAmount, block.timestamp);\n  }\n\n  /// @notice Get lab's total revenue\n  /// @param labId The lab identifier\n  /// @return totalRevenue Amount of revenue received by the lab\n  function getLabTotalRevenue(uint256 labId) external view returns (uint256) {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    return hs.labs[labId].totalRevenue;\n  }\n\n  /// @notice Get revenue distribution percentages for a purchase (100% total)\n  /// @param amount The purchase amount\n  /// @return buyback H1 Holders buyback (40%)\n  /// @return developer App developer incentive (15%)\n  /// @return creator Data creators/collectors (20%)\n  /// @return scholar Scholars/supervisors (20%)\n  /// @return treasury H1 protocol treasury (5%)\n  function getRevenueBreakdown(uint256 amount)\n    external\n    pure\n    returns (\n      uint256 buyback,\n      uint256 developer,\n      uint256 creator,\n      uint256 scholar,\n      uint256 treasury\n    )\n  {\n    buyback = (amount * BUYBACK_H1_HOLDERS_BPS) / BPS_DENOMINATOR;\n    developer = (amount * APP_DEVELOPER_BPS) / BPS_DENOMINATOR;\n    creator = (amount * DATA_CREATORS_BPS) / BPS_DENOMINATOR;\n    scholar = (amount * SCHOLARS_BPS) / BPS_DENOMINATOR;\n    treasury = (amount * H1_TREASURY_BPS) / BPS_DENOMINATOR;\n  }\n}\n\n\n"},"contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  /// @notice Data record with provenance and human supervision metadata\n  /// @dev Tracks creator, supervisor, content hash, and delta-gain for revenue attribution\n  struct DataRecord {\n    address creator;                // 20 bytes: who created the data\n    address supervisor;             // 20 bytes: who reviewed/approved\n    address pendingSupervisor;      // 20 bytes: supervisor awaiting approval\n    address baseModel;              // 20 bytes: model used to generate\n    uint256 labId;                  // 32 bytes: associated lab\n    bytes32 dataHash;               // 32 bytes: IPFS/Arweave content hash\n    string domain;                  // variable: data domain (medical, research, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=APPROVED, 2=REJECTED\n    uint256 deltaGainScore;         // 32 bytes: improvement vs base model (0-10000 bps)\n    bytes32 approvalSignature;      // 32 bytes: supervisor's signature hash\n    uint256 createdAt;              // 32 bytes: creation timestamp\n    uint256 approvedAt;             // 32 bytes: approval timestamp (0 if not approved)\n  }\n\n  /// @notice Attribution record for revenue distribution\n  /// @dev Links creator, supervisor, and delta-gain to data ID for correct splits\n  struct Attribution {\n    address creator;                // 20 bytes: data creator\n    address supervisor;             // 20 bytes: human supervisor\n    uint256 labId;                  // 32 bytes: lab ID\n    uint256 deltaGainScore;         // 32 bytes: delta-gain percentage (bps)\n    uint256 revenueShare;           // 32 bytes: revenue allocated to data\n    uint256 recordedAt;             // 32 bytes: when recorded\n  }\n\n  /// @notice User credential record\n  /// @dev Tracks individual credentials issued to users with verification status\n  struct Credential {\n    uint256 credentialId;           // 32 bytes: unique credential ID\n    address holder;                 // 20 bytes: credential holder address\n    uint256 userId;                 // 32 bytes: associated user ID\n    address issuer;                 // 20 bytes: organization/body that issued\n    string credentialType;          // variable: type (physician, engineer, etc)\n    string domain;                  // variable: domain (medical, finance, etc)\n    uint256 status;                 // 32 bytes: 0=PENDING, 1=VERIFIED, 2=REVOKED\n    bytes32 offChainVerificationHash; // 32 bytes: IPFS/Arweave verification doc\n    uint256 issuedAt;               // 32 bytes: issuance timestamp\n    uint256 verifiedAt;             // 32 bytes: verification timestamp (0 if pending)\n    uint256 revokedAt;              // 32 bytes: revocation timestamp (0 if active)\n  }\n\n  /// @notice User profile with credential tracking\n  /// @dev Aggregates credential information for quick access\n  struct UserProfile {\n    address userAddress;            // 20 bytes: associated address\n    string domainFocus;             // variable: primary domain focus\n    uint256 createdAt;              // 32 bytes: profile creation timestamp\n    uint256 credentialCount;        // 32 bytes: total issued credentials\n    uint256 verifiedCredentialCount;// 32 bytes: verified credentials\n    bool isActive;                  // 1 byte: profile active status\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n    // ============ Data Validation Storage ============\n    // Data records indexed by dataId\n    mapping(uint256 => DataRecord) dataRecords;\n    // Attribution records indexed by dataId\n    mapping(uint256 => Attribution) attributionRecords;\n    // All data IDs for a lab\n    mapping(uint256 => uint256[]) labDataRecords;\n    // Next data ID counter\n    uint256 nextDataId;\n    // ============ Credentialing Storage ============\n    // User ID management\n    mapping(address => uint256) userAddressToId;    // address → userId\n    mapping(uint256 => address) userIdToAddress;    // userId → address\n    mapping(uint256 => UserProfile) userProfiles;   // userId → profile\n    uint256 nextUserId;                             // userId counter\n    // Credential management\n    mapping(uint256 => Credential) credentials;     // credentialId → record\n    mapping(uint256 => uint256[]) userCredentials;  // userId → [credentialIds]\n    uint256 nextCredentialId;                       // credentialId counter\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}