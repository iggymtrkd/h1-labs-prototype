{"language":"Solidity","sources":{"contracts/contracts/facets/RevenueFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\n\n/// @title RevenueFacet\n/// @notice Handles revenue distribution for labs with reentrancy protection\n/// @dev Implements checks-effects-interactions pattern with custom reentrancy guard\ncontract RevenueFacet {\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n\n  uint256 private constant LAB_OWNER_SHARE_BPS = 5000; // 50%\n  uint256 private constant H1_POOL_SHARE_BPS = 2500;   // 25%\n  uint256 private constant BUYBACK_SHARE_BPS = 2500;   // 25%\n  uint256 private constant BPS_DENOMINATOR = 10000;\n\n  event RevenueDistributed(uint256 indexed labId, uint256 labOwner, uint256 h1Pool, uint256 buyback);\n\n  error ReentrancyGuard();\n  error InvalidLabId();\n  error InvalidAmount();\n  error TransferFailed();\n\n  modifier nonReentrant() {\n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    if (hs.reentrancyStatus == ENTERED) revert ReentrancyGuard();\n    hs.reentrancyStatus = ENTERED;\n    _;\n    hs.reentrancyStatus = NOT_ENTERED;\n  }\n\n  /// @notice Distributes revenue to lab owner, H1 pool, and buyback reserve\n  /// @dev Uses checks-effects-interactions pattern to prevent reentrancy\n  /// @param labId The lab identifier to distribute revenue for\n  /// @custom:reverts InvalidAmount if msg.value is zero\n  /// @custom:reverts InvalidLabId if lab doesn't exist\n  /// @custom:reverts TransferFailed if ETH transfer fails\n  function distributeRevenue(uint256 labId) external payable nonReentrant {\n    uint256 amount = msg.value;\n    if (amount == 0) revert InvalidAmount();\n    \n    LibH1Storage.H1Storage storage hs = LibH1Storage.h1Storage();\n    LibH1Storage.Lab storage lab = hs.labs[labId];\n    \n    if (lab.owner == address(0)) revert InvalidLabId();\n\n    // Calculate shares\n    uint256 labOwnerAmt = (amount * LAB_OWNER_SHARE_BPS) / BPS_DENOMINATOR;\n    uint256 h1PoolAmt = (amount * H1_POOL_SHARE_BPS) / BPS_DENOMINATOR;\n    uint256 buybackAmt = amount - labOwnerAmt - h1PoolAmt;\n\n    // Update state before external calls\n    lab.totalRevenue += amount;\n    \n    // Emit event before external calls\n    emit RevenueDistributed(labId, labOwnerAmt, h1PoolAmt, buybackAmt);\n\n    // External calls last (checks-effects-interactions pattern)\n    (bool successOwner, ) = payable(lab.owner).call{value: labOwnerAmt}(\"\");\n    if (!successOwner) revert TransferFailed();\n\n    // Route H1 pool share to protocol treasury to avoid calling non-existent functions\n    address treasury = hs.protocolTreasury;\n    if (treasury != address(0) && h1PoolAmt > 0) {\n      (bool successTreasury, ) = payable(treasury).call{value: h1PoolAmt}(\"\");\n      if (!successTreasury) revert TransferFailed();\n    }\n\n    // Buyback amount remains in contract; a future function can execute buyback controlled by owner\n  }\n}\n\n\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}