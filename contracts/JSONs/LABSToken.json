{"language":"Solidity","sources":{"contracts/contracts/facets/TreasuryFacet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LABSToken } from \"../tokens/LABSToken.sol\";\nimport { LibDiamond } from \"../diamond-standard/libraries/LibDiamond.sol\";\nimport { LibH1Storage } from \"../libraries/LibH1Storage.sol\";\n\n/// @title TreasuryFacet\n/// @notice Manages LABS token configuration and protocol treasury operations\n/// @dev Diamond facet for H1 Labs treasury management\ncontract TreasuryFacet {\n\n  event BuybackExecuted(uint256 amount, address indexed executor);\n  event LABSTokenUpdated(address indexed newToken);\n\n  /// @notice Sets the LABS token address for the platform\n  /// @dev Only callable by diamond owner. Validates address and contract existence\n  /// @param token Address of the LABS token contract\n  function setLABSToken(address token) external {\n    LibDiamond.enforceIsContractOwner();\n    require(token != address(0), \"TreasuryFacet: token is zero address\");\n    require(token.code.length > 0, \"TreasuryFacet: not a contract\");\n    LibH1Storage.h1Storage().labsToken = token;\n    emit LABSTokenUpdated(token);\n  }\n\n  /// @notice TESTING FUNCTION ONLY - Simulates LABS token buyback operation\n  /// @dev ⚠️ IMPORTANT: This is a STUB for testing purposes only\n  /// \n  /// This function is intentionally simplified and ONLY emits an event.\n  /// It does NOT perform any actual token transfers or buyback logic.\n  /// \n  /// PURPOSE:\n  ///   - Testing event emissions and access control\n  ///   - Validating owner-only restrictions\n  ///   - Simulating buyback flows in development/test environments\n  /// \n  /// SECURITY:\n  ///   - Only callable by diamond owner (enforced via LibDiamond.enforceIsContractOwner())\n  ///   - No funds are moved or tokens burned/transferred\n  ///   - Safe for testing without risk of actual economic impact\n  /// \n  /// FUTURE IMPLEMENTATION:\n  ///   In production, this should include:\n  ///   - AMM/DEX integration for market buybacks\n  ///   - Token burning mechanism\n  ///   - Price impact calculations\n  ///   - Slippage protection\n  ///   - Treasury balance management\n  /// \n  /// @param amount The amount of LABS tokens to simulate buying back (for event logging only)\n  /// @custom:security Only diamond owner can call this function\n  /// @custom:testing This is a testing stub - does not perform actual buybacks\n  function buybackLABS(uint256 amount) external {\n    LibDiamond.enforceIsContractOwner();\n    require(amount > 0, \"TreasuryFacet: zero amount\");\n    require(LibH1Storage.h1Storage().labsToken != address(0), \"TreasuryFacet: token not set\");\n    \n    // ⚠️ TESTING ONLY - No actual buyback logic implemented\n    // This function only validates access control and emits an event for testing\n    emit BuybackExecuted(amount, msg.sender);\n  }\n}\n\n\n"},"contracts/contracts/libraries/LibH1Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title LibH1Storage\n/// @notice Diamond storage library for H1 Labs platform state\n/// @dev Uses diamond storage pattern to avoid storage collisions during upgrades\nlibrary LibH1Storage {\n  bytes32 internal constant H1_STORAGE_POSITION = keccak256(\"h1.labs.storage.v1\");\n\n  /// @notice Lab metadata and state (optimized struct packing: 5 slots)\n  /// @dev Packed to minimize storage slots from 6 to 5 slots\n  struct Lab {\n    address owner;          // slot 0: 20 bytes\n    address h1Token;        // slot 1: 20 bytes\n    uint96 totalStaked;     // slot 2: 12 bytes (packed with active)\n    bool active;            // slot 2: 1 byte (packed with totalStaked) - 11 bytes padding\n    uint256 totalRevenue;   // slot 3: 32 bytes\n    string domain;          // slot 4+: dynamic\n  }\n\n  struct H1Storage {\n    mapping(uint256 => Lab) labs;\n    uint256 nextLabId;\n    // Global config\n    address labsToken;\n    uint64 defaultCooldown;\n    uint16 defaultExitCapBps;\n    address protocolTreasury;\n    uint16 curveFeeBps;\n    uint16 curvePolBps;\n    // Global guards/state (shared across facets)\n    uint256 reentrancyStatus; // 1 = NOT_ENTERED, 2 = ENTERED\n    // Domain registry and staking balances (moved from facets to avoid storage collisions)\n    mapping(bytes32 => bool) domainTaken; // keccak256(domain) => taken\n    mapping(address => uint256) stakedBalances; // user => LABS staked amount\n    // Per-lab vault address (ERC-4626-style)\n    mapping(uint256 => address) labIdToVault;\n    // Per-lab LabPass NFT\n    mapping(uint256 => address) labIdToLabPass;\n    // Per-lab bonding curve sale contract\n    mapping(uint256 => address) labIdToCurve;\n  }\n\n  function h1Storage() internal pure returns (H1Storage storage hs) {\n    bytes32 position = H1_STORAGE_POSITION;\n    assembly {\n      hs.slot := position\n    }\n  }\n}\n\n\n"},"contracts/contracts/diamond-standard/libraries/LibDiamond.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\nlibrary LibDiamond {\n  bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint96 selectorPosition;\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint256 facetAddressPosition;\n  }\n\n  struct DiamondStorage {\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    address[] facetAddresses;\n    address contractOwner;\n    mapping(address => bool) approvedInitializers; // Whitelist for delegatecall\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  event InitializerApproved(address indexed initializer);\n  event InitializerRevoked(address indexed initializer);\n\n  error NotContractOwner(address sender, address owner);\n  error InitZeroAddress();\n  error InitCallFailed(bytes data);\n  error InitializerNotApproved(address initializer);\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  function setContractOwner(address _newOwner) internal {\n    DiamondStorage storage ds = diamondStorage();\n    address previousOwner = ds.contractOwner;\n    ds.contractOwner = _newOwner;\n    emit OwnershipTransferred(previousOwner, _newOwner);\n  }\n\n  function enforceIsContractOwner() internal view {\n    DiamondStorage storage ds = diamondStorage();\n    if (msg.sender != ds.contractOwner) {\n      revert NotContractOwner(msg.sender, ds.contractOwner);\n    }\n  }\n\n  function diamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    uint256 length = _diamondCut.length; // Cache array length for gas optimization\n    for (uint256 facetIndex; facetIndex < length; ) {\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n      if (action == IDiamondCut.FacetCutAction.Add) {\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      }\n      unchecked { ++facetIndex; } // Safe: facetIndex < length\n    }\n    emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);\n    initializeDiamondCut(_init, _calldata);\n  }\n\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to add\");\n    DiamondStorage storage ds = diamondStorage();\n    uint256 selectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length;\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress == address(0), \"LibDiamond: Selector already exists\");\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      unchecked { \n        ++selectorPosition;\n        ++selectorIndex;\n      } // Safe: bounded by array length\n    }\n  }\n\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to replace\");\n    DiamondStorage storage ds = diamondStorage();\n    uint256 selectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length;\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress != _facetAddress, \"LibDiamond: Replace facet is same\");\n      removeFunction(ds, oldFacetAddress, selector);\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      unchecked { \n        ++selectorPosition;\n        ++selectorIndex;\n      } // Safe: bounded by array length\n    }\n  }\n\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_facetAddress == address(0), \"LibDiamond: Remove facetAddress must be address(0)\");\n    uint256 length = _functionSelectors.length;\n    require(length > 0, \"LibDiamond: No selectors to remove\");\n    DiamondStorage storage ds = diamondStorage();\n    for (uint256 selectorIndex; selectorIndex < length; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      removeFunction(ds, oldFacetAddress, selector);\n      unchecked { ++selectorIndex; } // Safe: bounded by array length\n    }\n  }\n\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n    require(_facetAddress != address(0), \"LibDiamond: Add facet address(0)\");\n    require(_facetAddress.code.length > 0, \"LibDiamond: Add facet has no code\");\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n    ds.facetAddresses.push(_facetAddress);\n  }\n\n  function addFunction(\n    DiamondStorage storage ds,\n    bytes4 _selector,\n    uint256 _selectorPosition,\n    address _facetAddress\n  ) internal {\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    ds.selectorToFacetAndPosition[_selector].selectorPosition = uint96(_selectorPosition);\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n  }\n\n  function removeFunction(\n    DiamondStorage storage ds,\n    address _facetAddress,\n    bytes4 _selector\n  ) internal {\n    require(_facetAddress != address(0), \"LibDiamond: Remove facet address(0)\");\n    require(_facetAddress != address(this), \"LibDiamond: Can't remove immutable functions\");\n\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].selectorPosition;\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\n    if (selectorPosition != lastSelectorPosition) {\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n      ds.selectorToFacetAndPosition[lastSelector].selectorPosition = uint96(selectorPosition);\n    }\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n    delete ds.selectorToFacetAndPosition[_selector];\n\n    if (ds.facetFunctionSelectors[_facetAddress].functionSelectors.length == 0) {\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n      if (facetAddressPosition != lastFacetAddressPosition) {\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n      }\n      ds.facetAddresses.pop();\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n    }\n  }\n\n  /// @notice Approves an initializer contract for delegatecall\n  /// @dev Only callable by contract owner\n  /// @param initializer Address of initializer contract to approve\n  function approveInitializer(address initializer) internal {\n    DiamondStorage storage ds = diamondStorage();\n    ds.approvedInitializers[initializer] = true;\n    emit InitializerApproved(initializer);\n  }\n\n  /// @notice Revokes an initializer contract\n  /// @dev Only callable by contract owner\n  /// @param initializer Address of initializer contract to revoke\n  function revokeInitializer(address initializer) internal {\n    DiamondStorage storage ds = diamondStorage();\n    ds.approvedInitializers[initializer] = false;\n    emit InitializerRevoked(initializer);\n  }\n\n  /// @notice Checks if an initializer is approved\n  /// @param initializer Address to check\n  /// @return True if approved, false otherwise\n  function isInitializerApproved(address initializer) internal view returns (bool) {\n    DiamondStorage storage ds = diamondStorage();\n    return ds.approvedInitializers[initializer];\n  }\n\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n    if (_init == address(0)) {\n      if (_calldata.length > 0) revert InitZeroAddress();\n      return;\n    }\n    \n    // Verify initializer is approved for security\n    DiamondStorage storage ds = diamondStorage();\n    if (!ds.approvedInitializers[_init]) {\n      revert InitializerNotApproved(_init);\n    }\n    \n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\n    if (!success) revert InitCallFailed(error);\n  }\n}\n\n\n\n"},"contracts/contracts/tokens/LABSToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC20Base } from \"./ERC20Base.sol\";\n\ncontract LABSToken is ERC20Base {\n  address private _owner;\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  modifier onlyOwner() {\n    require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  constructor(address initialOwner) ERC20Base(\"LABS\", \"LABS\", 18) {\n    _owner = initialOwner;\n  }\n\n  function owner() external view returns (address) { return _owner; }\n\n  function transferOwnership(address newOwner) external onlyOwner { \n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    address prev = _owner;\n    _owner = newOwner; \n    emit OwnershipTransferred(prev, newOwner);\n  }\n\n  function mint(address to, uint256 amount) external onlyOwner { _mint(to, amount); }\n}\n\n\n"},"contracts/contracts/tokens/ERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC20Base\n/// @notice Gas-optimized ERC20 base implementation with assembly optimizations\n/// @dev Uses assembly for critical path operations to minimize gas costs\nabstract contract ERC20Base {\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n  uint256 private _totalSupply;\n\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) { return _name; }\n  function symbol() public view returns (string memory) { return _symbol; }\n  function decimals() public view returns (uint8) { return _decimals; }\n  function totalSupply() public view returns (uint256) { return _totalSupply; }\n  function balanceOf(address account) public view returns (uint256) { return _balances[account]; }\n  function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; }\n\n  function transfer(address to, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[from][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked { _approve(from, msg.sender, currentAllowance - amount); }\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /// @notice Internal transfer function with assembly optimization\n  /// @dev Uses assembly for gas-efficient balance updates\n  /// @param from Address to transfer from\n  /// @param to Address to transfer to\n  /// @param amount Amount to transfer\n  function _transfer(address from, address to, uint256 amount) internal {\n    require(from != address(0) && to != address(0), \"ERC20: zero address\");\n    \n    // Assembly optimized balance operations\n    assembly {\n      // Load balance storage slot for 'from'\n      mstore(0x00, from)\n      mstore(0x20, _balances.slot)\n      let fromBalanceSlot := keccak256(0x00, 0x40)\n      let fromBalance := sload(fromBalanceSlot)\n      \n      // Check sufficient balance\n      if lt(fromBalance, amount) {\n        mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000) // Error selector\n        mstore(0x04, 0x20)\n        mstore(0x24, 27)\n        mstore(0x44, \"ERC20: transfer exceeds balance\")\n        revert(0x00, 0x64)\n      }\n      \n      // Update from balance\n      sstore(fromBalanceSlot, sub(fromBalance, amount))\n      \n      // Load and update balance storage slot for 'to'\n      mstore(0x00, to)\n      let toBalanceSlot := keccak256(0x00, 0x40)\n      let toBalance := sload(toBalanceSlot)\n      sstore(toBalanceSlot, add(toBalance, amount))\n    }\n    \n    emit Transfer(from, to, amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0) && spender != address(0), \"ERC20: zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: mint to zero\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal {\n    uint256 fromBal = _balances[from];\n    require(fromBal >= amount, \"ERC20: burn exceeds balance\");\n    unchecked { _balances[from] = fromBal - amount; }\n    _totalSupply -= amount;\n    emit Transfer(from, address(0), amount);\n  }\n\n  /// @notice Batch transfer tokens to multiple recipients (gas optimized)\n  /// @dev Useful for airdrops and mass distributions\n  /// @param recipients Array of recipient addresses\n  /// @param amounts Array of amounts to transfer\n  /// @return success True if all transfers succeeded\n  function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) public returns (bool success) {\n    uint256 length = recipients.length;\n    require(length == amounts.length, \"ERC20: length mismatch\");\n    \n    for (uint256 i; i < length; ) {\n      _transfer(msg.sender, recipients[i], amounts[i]);\n      unchecked { ++i; }\n    }\n    \n    return true;\n  }\n}\n\n\n"},"contracts/contracts/diamond-standard/interfaces/IERC173.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC-173: Ownership Standard\ninterface IERC173 {\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function owner() external view returns (address owner_);\n\n  function transferOwnership(address _newOwner) external;\n}\n\n\n\n"},"contracts/contracts/diamond-standard/interfaces/IDiamondCut.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDiamondCut {\n  enum FacetCutAction { Add, Replace, Remove }\n\n  struct FacetCut {\n    address facetAddress;\n    FacetCutAction action;\n    bytes4[] functionSelectors;\n  }\n\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  function diamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external;\n}\n\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}