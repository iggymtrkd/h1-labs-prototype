{"language":"Solidity","sources":{"contracts/contracts/factories/LabVaultFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LabVault } from \"../vaults/LabVault.sol\";\nimport { LibLabVaultFactory } from \"../libraries/LibLabVaultFactory.sol\";\n\n/// @title LabVaultFactory\n/// @notice External factory for deploying LabVault contracts\n/// @dev Separates vault bytecode from facets to reduce contract size\ncontract LabVaultFactory {\n  event VaultDeployed(address indexed vault, address indexed owner);\n  \n  /// @notice Create and initialize a new LabVault contract (part 1 - metadata)\n  /// @dev Must call finalizeVault after this\n  function createVault(\n    string calldata h1Name,\n    string calldata h1Symbol,\n    string calldata labDisplayName\n  ) external returns (address vault) {\n    // Deploy with zero parameters\n    LabVault vaultContract = new LabVault();\n    vault = address(vaultContract);\n    \n    // Initialize metadata only\n    vaultContract.initializeMetadata(h1Name, h1Symbol, labDisplayName);\n  }\n  \n  /// @notice Finalize vault configuration (part 2)\n  /// @dev Must be called after createVault\n  function finalizeVault(\n    address vault,\n    address labsToken,\n    uint64 cooldownSeconds,\n    uint16 epochExitCapBps,\n    address admin,\n    address labOwner,\n    address treasury,\n    address diamond\n  ) external {\n    LabVault(vault).initializeConfig(\n      labsToken,\n      cooldownSeconds,\n      epochExitCapBps,\n      admin,\n      labOwner,\n      treasury,\n      diamond\n    );\n    \n    emit VaultDeployed(vault, labOwner);\n  }\n}\n"},"contracts/contracts/libraries/LibLabVaultFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @notice Library containing types and constants for LabVault deployment\nlibrary LibLabVaultFactory {\n  /// @notice Constructor parameters struct to avoid stack too deep\n  struct ConstructorParams {\n    address labsToken;\n    string h1Name;\n    string h1Symbol;\n    string labDisplayName;\n    uint64 cooldownSeconds;\n    uint16 epochExitCapBps;\n    address admin;\n    address labOwner;\n    address treasury;\n    address diamond;\n  }\n}\n\n"},"contracts/contracts/vaults/LabVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ERC20Base } from \"../tokens/ERC20Base.sol\";\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\nimport { LibLabVaultFactory } from \"../libraries/LibLabVaultFactory.sol\";\n\ncontract LabVault is ERC20Base {\n  address public labsToken;\n  string public labDisplayName;\n  address public admin;\n  address public labOwner;           // New: Lab owner receives 1.5% of fees\n  address public treasury;           // New: H1 treasury receives 1% of fees\n\n  uint256 public constant LEVEL1 = 100_000e18;\n  uint256 public constant LEVEL2 = 250_000e18;\n  uint256 public constant LEVEL3 = 500_000e18;\n  uint16 public constant MAX_EXIT_CAP_BPS = 10_000; // 100%\n  uint16 public constant MAX_TOTAL_FEE_BPS = 250;   // 2.5% max total fee (1.5% + 1%)\n\n  uint64 public cooldownSeconds;\n  uint16 public epochExitCapBps;\n  uint64 public epochStart;\n  \n  // Fee configuration (basis points) - Total: 2.5% (1.5% + 1%)\n  uint16 public depositFeeLabOwnerBps = 150;        // 1.5% to lab owner (default)\n  uint16 public depositFeeTreasuryBps = 100;        // 1% to treasury (default)\n  uint16 public redemptionFeeLabOwnerBps = 150;     // 1.5% to lab owner (default)\n  uint16 public redemptionFeeTreasuryBps = 100;     // 1% to treasury (default)\n\n  uint256 public totalAssets;\n  uint256 public pendingExitAssets;\n  uint256 public epochExitedAssets;\n\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n  uint256 private status = NOT_ENTERED;\n\n  modifier nonReentrant() {\n    require(status == NOT_ENTERED, \"reentrancy\");\n    status = ENTERED;\n    _;\n    status = NOT_ENTERED;\n  }\n\n  // Optimized struct packing: 2 storage slots instead of 4\n  struct RedeemRequest {\n    address owner;      // 20 bytes\n    uint64 unlockTime;  // 8 bytes  \n    bool claimed;       // 1 byte\n    // Total: 29 bytes in slot 1 (3 bytes padding)\n    uint256 assets;     // 32 bytes in slot 2\n  }\n\n  uint256 public nextRequestId;\n  mapping(uint256 => RedeemRequest) public redeemRequests;\n\n  event Deposited(address indexed caller, address indexed receiver, uint256 assets, uint256 shares);\n  event DepositFeeCollected(address indexed caller, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemRequested(uint256 indexed requestId, address indexed owner, uint256 sharesBurned, uint256 assets, uint64 unlockTime);\n  event RedemptionFeeCollected(uint256 indexed requestId, address indexed owner, uint256 labOwnerFee, uint256 treasuryFee);\n  event RedeemClaimed(uint256 indexed requestId, address indexed owner, uint256 assets);\n  event RedeemCanceled(uint256 indexed requestId, address indexed owner, uint256 assets, uint256 sharesReMinted);\n  event LevelChanged(uint8 newLevel, uint256 totalAssets);\n  event ExitCapsUpdated(uint64 cooldownSeconds, uint16 epochExitCapBps);\n  event EpochRolled(uint64 newEpochStart);\n  event RedeemFilled(uint256 indexed requestId, address indexed filler, uint256 assets, address receiver);\n  event AdminUpdated(address indexed newAdmin);\n  event LabOwnerUpdated(address indexed newLabOwner);\n  event TreasuryUpdated(address indexed newTreasury);\n  event FeesUpdated(uint16 depositLabOwnerBps, uint16 depositTreasuryBps, uint16 redemptionLabOwnerBps, uint16 redemptionTreasuryBps);\n  event Paused(address indexed account);\n  event Unpaused(address indexed account);\n  event InitialMintCompleted(uint256 totalMinted, address indexed diamond);\n\n  error Unauthorized();\n  error InvalidAddress();\n  error InvalidAmount();\n  error InvalidParameter();\n  error ContractPaused();\n  error InitialMintAlreadyCompleted();\n\n  bool private _paused;\n  bool public initialMintCompleted;  // Track if initial H1 distribution happened\n  address public diamond;   // H1Diamond address for auth\n  \n  bool private _initialized;  // Flag to prevent re-initialization\n\n  // Testing variables (TESTNET ONLY)\n  bool public testMode;\n  uint8 public overrideLevel;\n  uint256 public testTimeOffset;\n\n  modifier onlyAdmin() {\n    if (msg.sender != admin) revert Unauthorized();\n    _;\n  }\n\n  modifier whenNotPaused() {\n    if (_paused) revert ContractPaused();\n    _;\n  }\n\n  constructor() {\n    // Zero-parameter constructor to avoid stack depth issues\n    // All initialization happens in initialize functions\n  }\n\n  /// @notice Initialize vault metadata (step 1)\n  /// @dev Must be called first after deployment\n  function initializeMetadata(\n    string calldata h1Name,\n    string calldata h1Symbol,\n    string calldata labDisplayName_\n  ) external {\n    require(!_initialized, \"already initialized\");\n    require(bytes(h1Name).length > 0 && bytes(h1Name).length <= 50, \"invalid name\");\n    require(bytes(h1Symbol).length > 0 && bytes(h1Symbol).length <= 10, \"invalid symbol\");\n    \n    // Directly set internal variables to avoid function call overhead\n    _name = h1Name;\n    _symbol = h1Symbol;\n    labDisplayName = labDisplayName_;\n  }\n\n  /// @notice Initialize vault configuration (step 2 and final)\n  /// @dev Must be called after initializeMetadata\n  function initializeConfig(\n    address labsToken_,\n    uint64 cooldownSeconds_,\n    uint16 epochExitCapBps_,\n    address admin_,\n    address labOwner_,\n    address treasury_,\n    address diamond_\n  ) external {\n    require(!_initialized, \"already initialized\");\n    require(labsToken_ != address(0), \"labs token = 0\");\n    require(labOwner_ != address(0), \"lab owner = 0\");\n    require(treasury_ != address(0), \"treasury = 0\");\n    require(diamond_ != address(0), \"diamond = 0\");\n    require(epochExitCapBps_ <= MAX_EXIT_CAP_BPS, \"exit cap > 100%\");\n    \n    _initialized = true;\n    labsToken = labsToken_;\n    cooldownSeconds = cooldownSeconds_;\n    epochExitCapBps = epochExitCapBps_;\n    admin = admin_;\n    labOwner = labOwner_;\n    treasury = treasury_;\n    diamond = diamond_;\n  }\n\n  function assetsPerShare() public view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 1e18;\n    return (totalAssets * 1e18) / supply;\n  }\n\n  function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n    uint256 rate = assetsPerShare();\n    shares = (assets * 1e18) / rate;\n  }\n\n  function previewMint(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n    uint256 rate = assetsPerShare();\n    assets = (shares * rate) / 1e18;\n  }\n\n  /// @notice Preview deposit accounting for deposit fee\n  function previewDepositWithFee(uint256 assets) public view returns (uint256 shares, uint256 labOwnerFee, uint256 treasuryFee) {\n    labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    shares = previewDeposit(netAssets);\n  }\n\n  /// @notice Preview redemption accounting for redemption fee\n  function previewRedeemWithFee(uint256 shares) public view returns (uint256 assets, uint256 labOwnerFee, uint256 treasuryFee) {\n    assets = previewRedeem(shares);\n    labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n  }\n\n  function getLevel() public view returns (uint8 level) {\n    // If in test mode and override level is set, return it\n    if (testMode && overrideLevel > 0) {\n      return overrideLevel;\n    }\n    \n    // Normal level calculation\n    uint256 a = totalAssets;\n    if (a >= LEVEL3) return 3;\n    if (a >= LEVEL2) return 2;\n    if (a >= LEVEL1) return 1;\n    return 0;\n  }\n\n  function getAppSlots() external view returns (uint8 slots) {\n    uint8 level = getLevel();\n    if (level == 3) return 3;\n    if (level == 2) return 2;\n    if (level == 1) return 1;\n    return 0;\n  }\n\n  /// @notice Initial H1 mint on lab creation (one-time only)\n  /// @dev Called by H1Diamond during lab creation to distribute initial H1 tokens\n  /// @param labsAmount Total LABS backing this H1 issuance\n  /// @param recipients Array of recipient addresses [owner, curve, vault, vault, treasury]\n  /// @param amounts Array of H1 amounts [owner 30%, curve 10%, scholars 40%, devs 15%, treasury 5%]\n  /// @return totalH1Minted Total H1 tokens minted\n  function initialMint(\n    uint256 labsAmount,\n    address[] calldata recipients,\n    uint256[] calldata amounts\n  ) external nonReentrant returns (uint256 totalH1Minted) {\n    // Only diamond can call during lab creation\n    if (msg.sender != diamond) revert Unauthorized();\n    if (initialMintCompleted) revert InitialMintAlreadyCompleted();\n    if (recipients.length != 5 || amounts.length != 5) revert InvalidParameter();\n    \n    // Transfer LABS backing from diamond\n    require(\n      IERC20(labsToken).transferFrom(msg.sender, address(this), labsAmount),\n      \"LABS transfer failed\"\n    );\n    \n    // Update vault backing (no fees on initial mint)\n    totalAssets += labsAmount;\n    \n    // Mint H1 tokens to recipients\n    // recipients[0] = vault (owner vesting holder)\n    // recipients[1] = curve (liquid market making)\n    // recipients[2] = vault (scholar reserve holder)\n    // recipients[3] = vault (dev reserve holder)\n    // recipients[4] = treasury (instant distribution)\n    for (uint256 i = 0; i < recipients.length; i++) {\n      if (amounts[i] > 0) {\n        _mint(recipients[i], amounts[i]);\n        totalH1Minted += amounts[i];\n      }\n    }\n    \n    initialMintCompleted = true;\n    emit InitialMintCompleted(totalH1Minted, msg.sender);\n  }\n\n  function depositLABS(uint256 assets, address receiver) external nonReentrant whenNotPaused returns (uint256 shares) {\n    require(assets > 0, \"zero assets\");\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 netAssets = assets - (labOwnerFee + treasuryFee);\n    \n    shares = previewDeposit(netAssets);\n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), assets), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += netAssets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, netAssets, shares);\n  }\n\n  function mintShares(uint256 shares, address receiver) external nonReentrant whenNotPaused returns (uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewMint(shares);\n    \n    // Calculate fees\n    uint256 labOwnerFee = (assets * depositFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * depositFeeTreasuryBps) / 10_000;\n    uint256 totalRequired = assets + (labOwnerFee + treasuryFee);\n    \n    require(IERC20(labsToken).transferFrom(msg.sender, address(this), totalRequired), \"transferFrom fail\");\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    totalAssets += assets;\n    _mint(receiver, shares);\n    _maybeEmitLevelChange();\n    emit DepositFeeCollected(msg.sender, labOwnerFee, treasuryFee);\n    emit Deposited(msg.sender, receiver, assets, shares);\n  }\n\n  function requestRedeem(uint256 shares) external nonReentrant whenNotPaused returns (uint256 requestId, uint256 assets) {\n    require(shares > 0, \"zero shares\");\n    assets = previewRedeem(shares);\n    \n    // Calculate redemption fees\n    uint256 labOwnerFee = (assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (assets * redemptionFeeTreasuryBps) / 10_000;\n    \n    _rollEpochIfNeeded();\n    _checkAndAccrueExitCap(assets);\n    _burn(msg.sender, shares);\n    pendingExitAssets += assets;\n    uint64 unlockTime = uint64(_currentTime()) + cooldownSeconds;\n    requestId = ++nextRequestId;\n    redeemRequests[requestId] = RedeemRequest({ owner: msg.sender, assets: assets, unlockTime: unlockTime, claimed: false });\n    emit RedemptionFeeCollected(requestId, msg.sender, labOwnerFee, treasuryFee);\n    emit RedeemRequested(requestId, msg.sender, shares, assets, unlockTime);\n  }\n\n  function cancelRedeem(uint256 requestId) external nonReentrant returns (uint256 shares) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(r.owner == msg.sender, \"not owner\");\n    require(!r.claimed, \"claimed\");\n    uint256 assets = r.assets;\n    delete redeemRequests[requestId];\n    pendingExitAssets -= assets;\n    shares = previewDeposit(assets);\n    _mint(msg.sender, shares);\n    emit RedeemCanceled(requestId, msg.sender, assets, shares);\n  }\n\n  function claimRedeem(uint256 requestId) external nonReentrant {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    require(_currentTime() >= r.unlockTime, \"cooldown\");\n    pendingExitAssets -= r.assets;\n    r.claimed = true;\n    totalAssets -= r.assets;\n    \n    // Calculate and apply fees at claim time\n    uint256 labOwnerFee = (r.assets * redemptionFeeLabOwnerBps) / 10_000;\n    uint256 treasuryFee = (r.assets * redemptionFeeTreasuryBps) / 10_000;\n    uint256 netAssets = r.assets - (labOwnerFee + treasuryFee);\n    \n    // Distribute fees\n    if (labOwnerFee > 0) {\n      require(IERC20(labsToken).transfer(labOwner, labOwnerFee), \"lab owner fee transfer fail\");\n    }\n    if (treasuryFee > 0) {\n      require(IERC20(labsToken).transfer(treasury, treasuryFee), \"treasury fee transfer fail\");\n    }\n    \n    require(IERC20(labsToken).transfer(r.owner, netAssets), \"transfer fail\");\n    _maybeEmitLevelChange();\n    emit RedeemClaimed(requestId, r.owner, netAssets);\n  }\n\n  function fillRedeem(uint256 requestId, address receiver) external nonReentrant returns (uint256 sharesMinted) {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"claimed\");\n    _rollEpochIfNeeded();\n    uint256 assets = r.assets;\n    require(IERC20(labsToken).transferFrom(msg.sender, r.owner, assets), \"fill xfer fail\");\n    pendingExitAssets -= assets;\n    r.claimed = true;\n    sharesMinted = 0;\n    emit RedeemFilled(requestId, msg.sender, assets, receiver);\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    if (newAdmin == address(0)) revert InvalidAddress();\n    admin = newAdmin;\n    emit AdminUpdated(newAdmin);\n  }\n\n  function setLabOwner(address newLabOwner) external onlyAdmin {\n    if (newLabOwner == address(0)) revert InvalidAddress();\n    labOwner = newLabOwner;\n    emit LabOwnerUpdated(newLabOwner);\n  }\n\n  function setTreasury(address newTreasury) external onlyAdmin {\n    if (newTreasury == address(0)) revert InvalidAddress();\n    treasury = newTreasury;\n    emit TreasuryUpdated(newTreasury);\n  }\n\n  /// @notice Set deposit and redemption fees (in basis points)\n  /// @dev Both fees must be <= 100 bps (1%)\n  function setFees(uint16 depositLabOwnerBps_, uint16 depositTreasuryBps_, uint16 redemptionLabOwnerBps_, uint16 redemptionTreasuryBps_) external onlyAdmin {\n    require(depositLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"deposit lab owner fee too high\");\n    require(depositTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"deposit treasury fee too high\");\n    require(redemptionLabOwnerBps_ <= MAX_TOTAL_FEE_BPS, \"redemption lab owner fee too high\");\n    require(redemptionTreasuryBps_ <= MAX_TOTAL_FEE_BPS, \"redemption treasury fee too high\");\n    depositFeeLabOwnerBps = depositLabOwnerBps_;\n    depositFeeTreasuryBps = depositTreasuryBps_;\n    redemptionFeeLabOwnerBps = redemptionLabOwnerBps_;\n    redemptionFeeTreasuryBps = redemptionTreasuryBps_;\n    emit FeesUpdated(depositFeeLabOwnerBps, depositFeeTreasuryBps, redemptionFeeLabOwnerBps, redemptionFeeTreasuryBps);\n  }\n\n  function setCooldown(uint64 seconds_) external onlyAdmin {\n    if (seconds_ > 30 days) revert InvalidParameter();\n    cooldownSeconds = seconds_;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  function setEpochExitCapBps(uint16 bps) external onlyAdmin {\n    if (bps > MAX_EXIT_CAP_BPS) revert InvalidParameter();\n    epochExitCapBps = bps;\n    emit ExitCapsUpdated(cooldownSeconds, epochExitCapBps);\n  }\n\n  /// @notice Emergency pause of vault operations\n  /// @dev Only callable by admin\n  function pause() external onlyAdmin {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @notice Unpause vault operations\n  /// @dev Only callable by admin\n  function unpause() external onlyAdmin {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  /// @notice Returns pause status\n  function paused() external view returns (bool) {\n    return _paused;\n  }\n\n  function _maybeEmitLevelChange() internal {\n    emit LevelChanged(getLevel(), totalAssets);\n  }\n\n  function _rollEpochIfNeeded() internal {\n    if (_currentTime() >= epochStart + 86400) {\n      epochStart = uint64(_currentTime());\n      epochExitedAssets = 0;\n      emit EpochRolled(epochStart);\n    }\n  }\n\n  function _checkAndAccrueExitCap(uint256 assets) internal {\n    uint256 cap = (totalAssets * epochExitCapBps) / 10_000;\n    require(epochExitedAssets + assets <= cap, \"epoch cap\");\n    epochExitedAssets += assets;\n  }\n\n  // ============================================\n  // TESTING FUNCTIONS (TESTNET ONLY)\n  // ============================================\n  \n  /// @notice Enable/disable test mode\n  /// @dev Only admin can call. Test mode allows level override\n  function setTestMode(bool enabled) external onlyAdmin {\n    testMode = enabled;\n  }\n  \n  /// @notice Set override level (only works in test mode)\n  /// @dev Allows testing app slots without full TVL\n  function setOverrideLevel(uint8 level) external onlyAdmin {\n    require(level <= 3, \"invalid level\");\n    overrideLevel = level;\n  }\n  \n  /// @notice Set time offset for testing\n  /// @dev Allows fast-forwarding time to test cooldowns\n  function setTestTimeOffset(uint256 offset) external onlyAdmin {\n    require(offset <= 365 days, \"offset too large\");\n    testTimeOffset = offset;\n  }\n  \n  /// @notice Reset epoch (allows more exits immediately)\n  /// @dev Useful for testing exit caps\n  function resetEpoch() external onlyAdmin {\n    epochStart = uint64(_currentTime());\n    epochExitedAssets = 0;\n    emit EpochRolled(epochStart);\n  }\n  \n  /// @notice Force complete a redemption request (bypass cooldown)\n  /// @dev TESTNET ONLY - Allows immediate claim for testing\n  function forceCompleteRedemption(uint256 requestId) external onlyAdmin {\n    RedeemRequest storage r = redeemRequests[requestId];\n    require(!r.claimed, \"already claimed\");\n    r.unlockTime = uint64(_currentTime());\n  }\n  \n  /// @notice Get current time with offset applied\n  /// @dev Used internally for all time checks\n  function _currentTime() internal view returns (uint256) {\n    return block.timestamp + testTimeOffset;\n  }\n}"},"contracts/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20 {\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n  function transfer(address to, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n}\n\n"},"contracts/contracts/tokens/ERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC20Base\n/// @notice Gas-optimized ERC20 base implementation\n/// @dev Simplified for Remix compilation compatibility\nabstract contract ERC20Base {\n  string internal _name;\n  string internal _symbol;\n  uint8 internal _decimals;\n  uint256 internal _totalSupply;\n\n  mapping(address => uint256) internal _balances;\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  constructor() {\n    // Zero-parameter constructor to avoid stack depth issues\n    // Subclasses can directly set _name and _symbol (internal access)\n    _decimals = 18;\n  }\n\n  function name() public view returns (string memory) { return _name; }\n  function symbol() public view returns (string memory) { return _symbol; }\n  function decimals() public view returns (uint8) { return _decimals; }\n  function totalSupply() public view returns (uint256) { return _totalSupply; }\n  function balanceOf(address account) public view returns (uint256) { return _balances[account]; }\n  function allowance(address owner, address spender) public view returns (uint256) { return _allowances[owner][spender]; }\n\n  function transfer(address to, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[from][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked { _approve(from, msg.sender, currentAllowance - amount); }\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /// @notice Internal transfer function\n  /// @dev Simplified for stack depth compatibility\n  /// @param from Address to transfer from\n  /// @param to Address to transfer to\n  /// @param amount Amount to transfer\n  function _transfer(address from, address to, uint256 amount) internal {\n    require(from != address(0) && to != address(0), \"ERC20: zero address\");\n    require(_balances[from] >= amount, \"ERC20: transfer exceeds balance\");\n    \n    unchecked {\n      _balances[from] -= amount;\n      _balances[to] += amount;\n    }\n    \n    emit Transfer(from, to, amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0) && spender != address(0), \"ERC20: zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: mint to zero\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal {\n    uint256 fromBal = _balances[from];\n    require(fromBal >= amount, \"ERC20: burn exceeds balance\");\n    unchecked { _balances[from] = fromBal - amount; }\n    _totalSupply -= amount;\n    emit Transfer(from, address(0), amount);\n  }\n\n  /// @notice Batch transfer tokens to multiple recipients\n  /// @dev Useful for airdrops and mass distributions\n  /// @param recipients Array of recipient addresses\n  /// @param amounts Array of amounts to transfer\n  /// @return success True if all transfers succeeded\n  function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) public returns (bool success) {\n    uint256 length = recipients.length;\n    require(length == amounts.length, \"ERC20: length mismatch\");\n    \n    for (uint256 i; i < length; ) {\n      _transfer(msg.sender, recipients[i], amounts[i]);\n      unchecked { ++i; }\n    }\n    \n    return true;\n  }\n}\n\n\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}